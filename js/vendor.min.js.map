{"version":3,"file":"js/vendor.min.js","names":[],"mappings":"","sources":["js/vendor.js"],"sourcesContent":["/*\n * angular-mm-foundation\n * http://pineconellc.github.io/angular-foundation/\n\n * Version: 0.6.0 - 2015-04-13\n * License: MIT\n * (c) Pinecone, LLC\n */\nangular.module(\"mm.foundation\", [\"mm.foundation.tpls\", \"mm.foundation.accordion\",\"mm.foundation.alert\",\"mm.foundation.bindHtml\",\"mm.foundation.buttons\",\"mm.foundation.position\",\"mm.foundation.mediaQueries\",\"mm.foundation.dropdownToggle\",\"mm.foundation.interchange\",\"mm.foundation.transition\",\"mm.foundation.modal\",\"mm.foundation.offcanvas\",\"mm.foundation.pagination\",\"mm.foundation.tooltip\",\"mm.foundation.popover\",\"mm.foundation.progressbar\",\"mm.foundation.rating\",\"mm.foundation.tabs\",\"mm.foundation.topbar\",\"mm.foundation.tour\",\"mm.foundation.typeahead\"]);\nangular.module(\"mm.foundation.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-unsafe-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/topbar/has-dropdown.html\",\"template/topbar/toggle-top-bar.html\",\"template/topbar/top-bar-dropdown.html\",\"template/topbar/top-bar-section.html\",\"template/topbar/top-bar.html\",\"template/tour/tour.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\nangular.module('mm.foundation.accordion', [])\n\n.constant('accordionConfig', {\n  closeOthers: true\n})\n\n.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {\n\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if ( closeOthers ) {\n      angular.forEach(this.groups, function (group) {\n        if ( group !== openGroup ) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n  \n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function (event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if ( index !== -1 ) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('accordion', function () {\n  return {\n    restrict:'EA',\n    controller:'AccordionController',\n    transclude: true,\n    replace: false,\n    templateUrl: 'template/accordion/accordion.html'\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('accordionGroup', ['$parse', function($parse) {\n  return {\n    require:'^accordion',         // We need this directive to be inside an accordion\n    restrict:'EA',\n    transclude:true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl:'template/accordion/accordion-group.html',\n    scope:{ heading:'@' },        // Create an isolated scope and interpolate the heading attribute onto this scope\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      var getIsOpen, setIsOpen;\n\n      accordionCtrl.addGroup(scope);\n\n      scope.isOpen = false;\n      \n      if ( attrs.isOpen ) {\n        getIsOpen = $parse(attrs.isOpen);\n        setIsOpen = getIsOpen.assign;\n\n        scope.$parent.$watch(getIsOpen, function(value) {\n          scope.isOpen = !!value;\n        });\n      }\n\n      scope.$watch('isOpen', function(value) {\n        if ( value ) {\n          accordionCtrl.closeOthers(scope);\n        }\n        if ( setIsOpen ) {\n          setIsOpen(scope.$parent, value);\n        }\n      });\n    }\n  };\n}])\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n// <accordion-group>\n//   <accordion-heading>Heading containing HTML - <img src=\"...\"></accordion-heading>\n// </accordion-group>\n.directive('accordionHeading', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^accordionGroup',\n    compile: function(element, attr, transclude) {\n      return function link(scope, element, attr, accordionGroupCtrl) {\n        // Pass the heading to the accordion-group controller\n        // so that it can be transcluded into the right place in the template\n        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n        accordionGroupCtrl.setHeading(transclude(scope, function() {}));\n      };\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n// <div class=\"accordion-group\">\n//   <div class=\"accordion-heading\" ><a ... accordion-transclude=\"heading\">...</a></div>\n//   ...\n// </div>\n.directive('accordionTransclude', function() {\n  return {\n    require: '^accordionGroup',\n    link: function(scope, element, attr, controller) {\n      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n        if ( heading ) {\n          element.html('');\n          element.append(heading);\n        }\n      });\n    }\n  };\n});\n\nangular.module(\"mm.foundation.alert\", [])\n\n.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {\n  $scope.closeable = 'close' in $attrs;\n}])\n\n.directive('alert', function () {\n  return {\n    restrict:'EA',\n    controller:'AlertController',\n    templateUrl:'template/alert/alert.html',\n    transclude:true,\n    replace:true,\n    scope: {\n      type: '=',\n      close: '&'\n    }\n  };\n});\n\nangular.module('mm.foundation.bindHtml', [])\n\n  .directive('bindHtmlUnsafe', function () {\n    return function (scope, element, attr) {\n      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);\n      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {\n        element.html(value || '');\n      });\n    };\n  });\n\nangular.module('mm.foundation.buttons', [])\n\n.constant('buttonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass;\n  this.toggleEvent = buttonConfig.toggleEvent;\n}])\n\n.directive('btnRadio', function () {\n  return {\n    require: ['btnRadio', 'ngModel'],\n    controller: 'ButtonsController',\n    link: function (scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n      };\n\n      //ui->model\n      element.bind(buttonsCtrl.toggleEvent, function () {\n        if (!element.hasClass(buttonsCtrl.activeClass)) {\n          scope.$apply(function () {\n            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive('btnCheckbox', function () {\n  return {\n    require: ['btnCheckbox', 'ngModel'],\n    controller: 'ButtonsController',\n    link: function (scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n      \n      function getCheckboxValue(attributeValue, defaultValue) {\n        var val = scope.$eval(attributeValue);\n        return angular.isDefined(val) ? val : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.bind(buttonsCtrl.toggleEvent, function () {\n        scope.$apply(function () {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\nangular.module('mm.foundation.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$position', ['$document', '$window', function ($document, $window) {\n\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, \"position\") || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function (element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function (element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function (element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)\n        };\n      }\n    };\n  }]);\n\nangular.module(\"mm.foundation.mediaQueries\", [])\n    .factory('matchMedia', ['$document', '$window', function($document, $window) {\n        // MatchMedia for IE <= 9\n        return $window.matchMedia || (function matchMedia(doc, undefined){\n            var bool,\n                docElem = doc.documentElement,\n                refNode = docElem.firstElementChild || docElem.firstChild,\n                // fakeBody required for <FF4 when executed in <head>\n                fakeBody = doc.createElement(\"body\"),\n                div = doc.createElement(\"div\");\n\n            div.id = \"mq-test-1\";\n            div.style.cssText = \"position:absolute;top:-100em\";\n            fakeBody.style.background = \"none\";\n            fakeBody.appendChild(div);\n\n            return function (q) {\n                div.innerHTML = \"&shy;<style media=\\\"\" + q + \"\\\"> #mq-test-1 { width: 42px; }</style>\";\n                docElem.insertBefore(fakeBody, refNode);\n                bool = div.offsetWidth === 42;\n                docElem.removeChild(fakeBody);\n                return {\n                    matches: bool,\n                    media: q\n                };\n            };\n\n        }($document[0]));\n    }])\n    .factory('mediaQueries', ['$document', 'matchMedia', function($document, matchMedia) {\n        var head = angular.element($document[0].querySelector('head'));\n        head.append('<meta class=\"foundation-mq-topbar\" />');\n        head.append('<meta class=\"foundation-mq-small\" />');\n        head.append('<meta class=\"foundation-mq-medium\" />');\n        head.append('<meta class=\"foundation-mq-large\" />');\n\n        var regex = /^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g;\n        var queries = {\n            topbar: getComputedStyle(head[0].querySelector('meta.foundation-mq-topbar')).fontFamily.replace(regex, ''),\n            small : getComputedStyle(head[0].querySelector('meta.foundation-mq-small')).fontFamily.replace(regex, ''),\n            medium : getComputedStyle(head[0].querySelector('meta.foundation-mq-medium')).fontFamily.replace(regex, ''),\n            large : getComputedStyle(head[0].querySelector('meta.foundation-mq-large')).fontFamily.replace(regex, '')\n        };\n\n        return {\n            topbarBreakpoint: function () {\n                return !matchMedia(queries.topbar).matches;\n            },\n            small: function () {\n                return matchMedia(queries.small).matches;\n            },\n            medium: function () {\n                return matchMedia(queries.medium).matches;\n            },\n            large: function () {\n                return matchMedia(queries.large).matches;\n            }\n        };\n    }]);\n\n/*\n * dropdownToggle - Provides dropdown menu functionality\n * @restrict class or attribute\n * @example:\n\n   <a dropdown-toggle=\"#dropdown-menu\">My Dropdown Menu</a>\n   <ul id=\"dropdown-menu\" class=\"f-dropdown\">\n     <li ng-repeat=\"choice in dropChoices\">\n       <a ng-href=\"{{choice.href}}\">{{choice.text}}</a>\n     </li>\n   </ul>\n */\nangular.module('mm.foundation.dropdownToggle', [ 'mm.foundation.position', 'mm.foundation.mediaQueries' ])\n\n.controller('DropdownToggleController', ['$scope', '$attrs', 'mediaQueries', function($scope, $attrs, mediaQueries) {\n  this.small = function() {\n    return mediaQueries.small() && !mediaQueries.medium();\n  };\n}])\n\n.directive('dropdownToggle', ['$document', '$window', '$location', '$position', function ($document, $window, $location, $position) {\n  var openElement = null,\n      closeMenu   = angular.noop;\n  return {\n    restrict: 'CA',\n    scope: {\n      dropdownToggle: '@'\n    },\n    controller: 'DropdownToggleController',\n    link: function(scope, element, attrs, controller) {\n      var parent = element.parent();\n      var dropdown = angular.element($document[0].querySelector(scope.dropdownToggle));\n\n      var parentHasDropdown = function() {\n        return parent.hasClass('has-dropdown');\n      };\n\n      var onClick = function (event) {\n        dropdown = angular.element($document[0].querySelector(scope.dropdownToggle));\n        var elementWasOpen = (element === openElement);\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        if (!!openElement) {\n          closeMenu();\n        }\n\n        if (!elementWasOpen && !element.hasClass('disabled') && !element.prop('disabled')) {\n          dropdown.css('display', 'block'); // We display the element so that offsetParent is populated\n          var offset = $position.offset(element);\n          var parentOffset = $position.offset(angular.element(dropdown[0].offsetParent));\n          var dropdownWidth = dropdown.prop('offsetWidth');\n          var css = {\n            top: offset.top - parentOffset.top + offset.height + 'px'\n          };\n\n          if (controller.small()) {\n            css.left = Math.max((parentOffset.width - dropdownWidth) / 2, 8) + 'px';\n            css.position = 'absolute';\n            css.width = '95%';\n            css['max-width'] = 'none';\n          }\n          else {\n            var left = Math.round(offset.left - parentOffset.left);\n            var rightThreshold = $window.innerWidth - dropdownWidth - 8;\n            if (left > rightThreshold) {\n                left = rightThreshold;\n                dropdown.removeClass('left').addClass('right');\n            }\n            css.left = left + 'px';\n            css.position = null;\n            css['max-width'] = null;\n          }\n\n          dropdown.css(css);\n          element.addClass('expanded');\n\n          if (parentHasDropdown()) {\n            parent.addClass('hover');\n          }\n\n          openElement = element;\n\n          closeMenu = function (event) {\n            $document.off('click', closeMenu);\n            dropdown.css('display', 'none');\n            element.removeClass('expanded');\n            closeMenu = angular.noop;\n            openElement = null;\n            if (parent.hasClass('hover')) {\n              parent.removeClass('hover');\n            }\n          };\n          $document.on('click', closeMenu);\n        }\n      };\n\n      if (dropdown) {\n        dropdown.css('display', 'none');\n      }\n\n      scope.$watch('$location.path', function() { closeMenu(); });\n\n      element.on('click', onClick);\n      element.on('$destroy', function() {\n        element.off('click', onClick);\n      });\n    }\n  };\n}]);\n\n/**\n * @ngdoc service\n * @name mm.foundation.interchange\n * @description\n *\n * Package containing all services and directives\n * about the `interchange` module\n */\nangular.module('mm.foundation.interchange', ['mm.foundation.mediaQueries'])\n\n  /**\n   * @ngdoc function\n   * @name mm.foundation.interchange.interchageQuery\n   * @function interchageQuery\n   * @description\n   *\n   * this service inject meta tags objects in the head\n   * to get the list of media queries from Foundation\n   * stylesheets.\n   *\n   * @return {object} Queries list name => mediaQuery\n   */\n  .factory('interchangeQueries', ['$document', function ($document) {\n    var element,\n      mediaSize,\n      formatList = {\n      'default': 'only screen',\n      landscape : 'only screen and (orientation: landscape)',\n      portrait : 'only screen and (orientation: portrait)',\n      retina : 'only screen and (-webkit-min-device-pixel-ratio: 2),' +\n        'only screen and (min--moz-device-pixel-ratio: 2),' +\n        'only screen and (-o-min-device-pixel-ratio: 2/1),' +\n        'only screen and (min-device-pixel-ratio: 2),' +\n        'only screen and (min-resolution: 192dpi),' +\n        'only screen and (min-resolution: 2dppx)'\n    },\n    classPrefix = 'foundation-mq-',\n    classList = ['small', 'medium', 'large', 'xlarge', 'xxlarge'],\n    head = angular.element($document[0].querySelector('head'));\n\n    for (var i = 0; i < classList.length; i++) {\n      head.append('<meta class=\"' + classPrefix + classList[i] + '\" />');\n      element = getComputedStyle(head[0].querySelector('meta.' + classPrefix + classList[i]));\n      mediaSize = element.fontFamily.replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, '');\n      formatList[classList[i]] = mediaSize;\n    }\n    return formatList;\n  }])\n\n  /**\n   * @ngdoc function\n   * @name mm.foundation.interchange.interchangeQueriesManager\n   * @function interchangeQueriesManager\n   * @description\n   *\n   * interface to add and remove named queries\n   * in the interchangeQueries list\n   */\n  .factory('interchangeQueriesManager', ['interchangeQueries', function (interchangeQueries) {\n    return {\n      /**\n       * @ngdoc method\n       * @name interchangeQueriesManager#add\n       * @methodOf mm.foundation.interchange.interchangeQueriesManager\n       * @description\n       *\n       * Add a custom media query in the `interchangeQueries`\n       * factory. This method does not allow to update an existing\n       * media query.\n       *\n       * @param {string} name MediaQuery name\n       * @param {string} media MediaQuery\n       * @returns {boolean} True if the insert is a success\n       */\n      add: function (name, media) {\n        if (!name || !media ||\n          !angular.isString(name) || !angular.isString(media) ||\n          !!interchangeQueries[name]) {\n          return false;\n        }\n        interchangeQueries[name] = media;\n        return true;\n      }\n    };\n  }])\n\n  /**\n   * @ngdoc function\n   * @name mm.foundation.interchange.interchangeTools\n   * @function interchangeTools\n   * @description\n   *\n   * Tools to help with the `interchange` module.\n   */\n  .factory('interchangeTools', ['$window', 'matchMedia', 'interchangeQueries', function ($window, matchMedia, namedQueries) {\n\n    /**\n     * @ngdoc method\n     * @name interchangeTools#parseAttribute\n     * @methodOf mm.foundation.interchange.interchangeTools\n     * @description\n     *\n     * Attribute parser to transform an `interchange` attribute\n     * value to an object with media query (name or query) as key,\n     * and file to use as value.\n     *\n     * ```\n     * {\n     *   small: 'bridge-500.jpg',\n     *   large: 'bridge-1200.jpg'\n     * }\n     * ```\n     *\n     * @param {string} value Interchange query string\n     * @returns {object} Attribute parsed\n     */\n    var parseAttribute = function (value) {\n      var raw = value.split(/\\[(.*?)\\]/),\n        i = raw.length,\n        breaker = /^(.+)\\,\\ \\((.+)\\)$/,\n        breaked,\n        output = {};\n\n      while (i--) {\n        if (raw[i].replace(/[\\W\\d]+/, '').length > 4) {\n          breaked = breaker.exec(raw[i]);\n          if (!!breaked && breaked.length === 3) {\n            output[breaked[2]] = breaked[1];\n          }\n        }\n      }\n      return output;\n    };\n\n    /**\n     * @ngdoc method\n     * @name interchangeTools#findCurrentMediaFile\n     * @methodOf mm.foundation.interchange.interchangeTools\n     * @description\n     *\n     * Find the current item to display from a file list\n     * (object returned by `parseAttribute`) and the\n     * current page dimensions.\n     *\n     * ```\n     * {\n     *   small: 'bridge-500.jpg',\n     *   large: 'bridge-1200.jpg'\n     * }\n     * ```\n     *\n     * @param {object} files Parsed version of `interchange` attribute\n     * @returns {string} File to display (or `undefined`)\n     */\n    var findCurrentMediaFile = function (files) {\n      var file, media, match;\n      for (file in files) {\n        media = namedQueries[file] || file;\n        match = matchMedia(media);\n        if (match.matches) {\n          return files[file];\n        }\n      }\n      return;\n    };\n\n    return {\n      parseAttribute: parseAttribute,\n      findCurrentMediaFile: findCurrentMediaFile\n    };\n  }])\n\n  /**\n   * @ngdoc directive\n   * @name mm.foundation.interchange.directive:interchange\n   * @restrict A\n   * @element DIV|IMG\n   * @priority 450\n   * @scope true\n   * @description\n   *\n   * Interchange directive, following the same features as\n   * ZURB documentation. The directive is splitted in 3 parts.\n   *\n   * 1. This directive use `compile` and not `link` for a simple\n   * reason: if the method is applied on a DIV element to\n   * display a template, the compile method will inject an ng-include.\n   * Because using a `templateUrl` or `template` to do it wouldn't\n   * be appropriate for all cases (`IMG` or dynamic backgrounds).\n   * And doing it in `link` is too late to be applied.\n   *\n   * 2. In the `compile:post`, the attribute is parsed to find\n   * out the type of content to display.\n   *\n   * 3. At the start and on event `resize`, the method `replace`\n   * is called to reevaluate which file is supposed to be displayed\n   * and update the value if necessary. The methd will also\n   * trigger a `replace` event.\n   */\n  .directive('interchange', ['$window', '$rootScope', 'interchangeTools', function ($window, $rootScope, interchangeTools) {\n\n    var pictureFilePattern = /[A-Za-z0-9-_]+\\.(jpg|jpeg|png|gif|bmp|tiff)\\ *,/i;\n\n    return {\n      restrict: 'A',\n      scope: true,\n      priority: 450,\n      compile: function compile($element, attrs) {\n        // Set up the attribute to update\n        if ($element[0].nodeName === 'DIV' && !pictureFilePattern.test(attrs.interchange)) {\n          $element.html('<ng-include src=\"currentFile\"></ng-include>');\n        }\n\n        return {\n          pre: function preLink($scope, $element, attrs) {},\n          post: function postLink($scope, $element, attrs) {\n            var currentFile, nodeName;\n\n            // Set up the attribute to update\n            nodeName = $element && $element[0] && $element[0].nodeName;\n            $scope.fileMap = interchangeTools.parseAttribute(attrs.interchange);\n\n            // Find the type of interchange\n            switch (nodeName) {\n            case 'DIV':\n              // If the tag is a div, we test the current file to see if it's picture\n              currentFile = interchangeTools.findCurrentMediaFile($scope.fileMap);\n              if (/[A-Za-z0-9-_]+\\.(jpg|jpeg|png|gif|bmp|tiff)$/i.test(currentFile)) {\n                $scope.type = 'background';\n              }\n              else {\n                $scope.type = 'include';\n              }\n              break;\n\n            case 'IMG':\n              $scope.type = 'image';\n              break;\n\n            default:\n              return;\n            }\n\n            var replace = function (e) {\n              // The the new file to display (exit if the same)\n              var currentFile = interchangeTools.findCurrentMediaFile($scope.fileMap);\n              if (!!$scope.currentFile && $scope.currentFile === currentFile) {\n                return;\n              }\n\n              // Set up the new file\n              $scope.currentFile = currentFile;\n              switch ($scope.type) {\n              case 'image':\n                $element.attr('src', $scope.currentFile);\n                break;\n\n              case 'background':\n                $element.css('background-image', 'url(' + $scope.currentFile + ')');\n                break;\n              }\n\n              // Trigger events\n              $rootScope.$emit('replace', $element, $scope);\n              if (!!e) {\n                $scope.$apply();\n              }\n            };\n\n            // Start\n            replace();\n            $window.addEventListener('resize', replace);\n            $scope.$on('$destroy', function () {\n              $window.removeEventListener('resize', replace);\n            });\n          }\n        };\n      }\n    };\n  }]);\n\nangular.module('mm.foundation.transition', [])\n\n/**\n * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\n * @param  {DOMElement} element  The DOMElement that will be animated.\n * @param  {string|object|function} trigger  The thing that will cause the transition to start:\n *   - As a string, it represents the css class to be added to the element.\n *   - As an object, it represents a hash of style attributes to be applied to the element.\n *   - As a function, it represents a function to be called that will cause the transition to occur.\n * @return {Promise}  A promise that is resolved when the transition finishes.\n */\n.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\n\n  var $transition = function(element, trigger, options) {\n    options = options || {};\n    var deferred = $q.defer();\n    var endEventName = $transition[options.animation ? \"animationEndEventName\" : \"transitionEndEventName\"];\n\n    var transitionEndHandler = function(event) {\n      $rootScope.$apply(function() {\n        element.unbind(endEventName, transitionEndHandler);\n        deferred.resolve(element);\n      });\n    };\n\n    if (endEventName) {\n      element.bind(endEventName, transitionEndHandler);\n    }\n\n    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\n    $timeout(function() {\n      if ( angular.isString(trigger) ) {\n        element.addClass(trigger);\n      } else if ( angular.isFunction(trigger) ) {\n        trigger(element);\n      } else if ( angular.isObject(trigger) ) {\n        element.css(trigger);\n      }\n      //If browser does not support transitions, instantly resolve\n      if ( !endEventName ) {\n        deferred.resolve(element);\n      }\n    });\n\n    // Add our custom cancel function to the promise that is returned\n    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\n    // i.e. it will therefore never raise a transitionEnd event for that transition\n    deferred.promise.cancel = function() {\n      if ( endEventName ) {\n        element.unbind(endEventName, transitionEndHandler);\n      }\n      deferred.reject('Transition cancelled');\n    };\n\n    return deferred.promise;\n  };\n\n  // Work out the name of the transitionEnd event\n  var transElement = document.createElement('trans');\n  var transitionEndEventNames = {\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'transitionend',\n    'OTransition': 'oTransitionEnd',\n    'transition': 'transitionend'\n  };\n  var animationEndEventNames = {\n    'WebkitTransition': 'webkitAnimationEnd',\n    'MozTransition': 'animationend',\n    'OTransition': 'oAnimationEnd',\n    'transition': 'animationend'\n  };\n  function findEndEventName(endEventNames) {\n    for (var name in endEventNames){\n      if (transElement.style[name] !== undefined) {\n        return endEventNames[name];\n      }\n    }\n  }\n  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\n  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\n  return $transition;\n}]);\n\nangular.module('mm.foundation.modal', ['mm.foundation.transition'])\n\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function () {\n    return {\n      createNew: function () {\n        var stack = [];\n\n        return {\n          add: function (key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function (key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function () {\n            return stack[stack.length - 1];\n          },\n          remove: function (key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function () {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function () {\n            return stack.length;\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('modalBackdrop', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n    return {\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/modal/backdrop.html',\n      link: function (scope) {\n\n        scope.animate = false;\n\n        //trigger CSS transitions\n        $timeout(function () {\n          scope.animate = true;\n        });\n\n        scope.close = function (evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {\n    return {\n      restrict: 'EA',\n      scope: {\n        index: '@',\n        animate: '='\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: 'template/modal/window.html',\n      link: function (scope, element, attrs) {\n        scope.windowClass = attrs.windowClass || '';\n\n        $timeout(function () {\n          // trigger CSS transitions\n          scope.animate = true;\n\n          // If the modal contains any autofocus elements refocus onto the first one\n          if (element[0].querySelectorAll('[autofocus]').length > 0) {\n            element[0].querySelectorAll('[autofocus]')[0].focus();\n          }\n          else{\n          // otherwise focus the freshly-opened modal\n            element[0].focus();\n          }\n        });\n      }\n    };\n  }])\n\n  .factory('$modalStack', ['$window', '$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',\n    function ($window, $transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {\n\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var $modalStack = {};\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex){\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance) {\n        var body = $document.find('body').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        //remove window DOM element\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {\n          modalWindow.modalScope.$destroy();\n          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);\n          checkRemoveBackdrop();\n        });\n      }\n\n      function checkRemoveBackdrop() {\n          //remove backdrop if no longer needed\n          if (backdropDomEl && backdropIndex() == -1) {\n            var backdropScopeRef = backdropScope;\n            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {\n              backdropScopeRef.$destroy();\n              backdropScopeRef = null;\n            });\n            backdropDomEl = undefined;\n            backdropScope = undefined;\n          }\n      }\n\n      function removeAfterAnimate(domEl, scope, emulateTime, done) {\n        // Closing animation\n        scope.animate = false;\n\n        var transitionEndEventName = $transition.transitionEndEventName;\n        if (transitionEndEventName) {\n          // transition out\n          var timeout = $timeout(afterAnimating, emulateTime);\n\n          domEl.bind(transitionEndEventName, function () {\n            $timeout.cancel(timeout);\n            afterAnimating();\n            scope.$apply();\n          });\n        } else {\n          // Ensure this call is async\n          $timeout(afterAnimating, 0);\n        }\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          domEl.remove();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind('keydown', function (evt) {\n        var modal;\n\n        if (evt.which === 27) {\n          modal = openedWindows.top();\n          if (modal && modal.value.keyboard) {\n            $rootScope.$apply(function () {\n              $modalStack.dismiss(modal.key);\n            });\n          }\n        }\n      });\n\n      $modalStack.open = function (modalInstance, modal) {\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard\n        });\n\n        var body = $document.find('body').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          backdropDomEl = $compile('<div modal-backdrop></div>')(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        // Create a faux modal div just to measure its\n        // distance to top\n        var faux = angular.element('<div class=\"reveal-modal\" style=\"z-index:-1\"\"></div>');\n        body.append(faux[0]);\n        var marginTop = parseInt(getComputedStyle(faux[0]).top) || 0;\n        faux.remove();\n\n        // Using pageYOffset instead of scrollY to ensure compatibility with IE\n        var scrollY = $window.pageYOffset || 0;\n        var openAt = scrollY + marginTop;\n\n        var angularDomEl = angular.element('<div modal-window style=\"visibility: visible; top:' + openAt +'px;\"></div>')\n          .attr({\n            'window-class': modal.windowClass,\n            'index': openedWindows.length() - 1,\n            'animate': 'animate'\n          });\n        angularDomEl.html(modal.content);\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        body.append(modalDomEl);\n        body.addClass(OPENED_MODAL_CLASS);\n      };\n\n      $modalStack.close = function (modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        if (modalWindow) {\n          modalWindow.deferred.resolve(result);\n          removeModalWindow(modalInstance);\n        }\n      };\n\n      $modalStack.dismiss = function (modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        if (modalWindow) {\n          modalWindow.deferred.reject(reason);\n          removeModalWindow(modalInstance);\n        }\n      };\n\n      $modalStack.dismissAll = function (reason) {\n        var topModal = this.getTop();\n        while (topModal) {\n          this.dismiss(topModal.key, reason);\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function () {\n        return openedWindows.top();\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$modal', function () {\n\n    var $modalProvider = {\n      options: {\n        backdrop: true, //can be also false or 'static'\n        keyboard: true\n      },\n      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',\n        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {\n\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $http.get(options.templateUrl, {cache: $templateCache}).then(function (result) {\n                return result.data;\n              });\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function (value, key) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              }\n            });\n            return promisesArr;\n          }\n\n          $modal.open = function (modalOptions) {\n\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              close: function (result) {\n                $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n\n            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {\n\n              var modalScope = (modalOptions.scope || $rootScope).$new();\n              modalScope.$close = modalInstance.close;\n              modalScope.$dismiss = modalInstance.dismiss;\n\n              var ctrlInstance, ctrlLocals = {};\n              var resolveIter = 1;\n\n              //controllers\n              if (modalOptions.controller) {\n                ctrlLocals.$scope = modalScope;\n                ctrlLocals.$modalInstance = modalInstance;\n                angular.forEach(modalOptions.resolve, function (value, key) {\n                  ctrlLocals[key] = tplAndVars[resolveIter++];\n                });\n\n                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                if (modalOptions.controllerAs) {\n                  modalScope[modalOptions.controllerAs] = ctrlInstance;\n                }\n              }\n\n              $modalStack.open(modalInstance, {\n                scope: modalScope,\n                deferred: modalResultDeferred,\n                content: tplAndVars[0],\n                backdrop: modalOptions.backdrop,\n                keyboard: modalOptions.keyboard,\n                windowClass: modalOptions.windowClass\n              });\n\n            }, function resolveError(reason) {\n              modalResultDeferred.reject(reason);\n            });\n\n            templateAndResolvePromise.then(function () {\n              modalOpenedDeferred.resolve(true);\n            }, function () {\n              modalOpenedDeferred.reject(false);\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module(\"mm.foundation.offcanvas\", [])\n    .directive('offCanvasWrap', ['$window', function ($window) {\n        return {\n            scope: {},\n            restrict: 'C',\n            link: function ($scope, element, attrs) {\n                var win = angular.element($window);\n                var sidebar = $scope.sidebar = element;\n\n                $scope.hide = function () {\n                    sidebar.removeClass('move-left');\n                    sidebar.removeClass('move-right');\n                };\n\n                win.bind(\"resize.body\", $scope.hide);\n\n                $scope.$on('$destroy', function() {\n                    win.unbind(\"resize.body\", $scope.hide);\n                });\n\n            },\n            controller: ['$scope', function($scope) {\n\n                this.leftToggle = function() {\n                    $scope.sidebar.toggleClass(\"move-right\");\n                };\n\n                this.rightToggle = function() {\n                    $scope.sidebar.toggleClass(\"move-left\");\n                };\n\n                this.hide = function() {\n                    $scope.hide();\n                };\n            }]\n        };\n    }])\n    .directive('leftOffCanvasToggle', [function () {\n        return {\n            require: '^offCanvasWrap',\n            restrict: 'C',\n            link: function ($scope, element, attrs, offCanvasWrap) {\n                element.on('click', function () {\n                    offCanvasWrap.leftToggle();\n                });\n            }\n        };\n    }])\n    .directive('rightOffCanvasToggle', [function () {\n        return {\n            require: '^offCanvasWrap',\n            restrict: 'C',\n            link: function ($scope, element, attrs, offCanvasWrap) {\n                element.on('click', function () {\n                    offCanvasWrap.rightToggle();\n                });\n            }\n        };\n    }])\n       .directive('exitOffCanvas', [function () {\n        return {\n            require: '^offCanvasWrap',\n            restrict: 'C',\n            link: function ($scope, element, attrs, offCanvasWrap) {\n                element.on('click', function () {\n                    offCanvasWrap.hide();\n                });\n            }\n        };\n    }])\n    .directive('offCanvasList', [function () {\n        return {\n            require: '^offCanvasWrap',\n            restrict: 'C',\n            link: function ($scope, element, attrs, offCanvasWrap) {\n                element.on('click', function () {\n                    offCanvasWrap.hide();\n                });\n            }\n        };\n    }]);\n\nangular.module('mm.foundation.pagination', [])\n\n.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {\n  var self = this,\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(defaultItemsPerPage) {\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = defaultItemsPerPage;\n    }\n  };\n\n  this.noPrevious = function() {\n    return this.page === 1;\n  };\n  this.noNext = function() {\n    return this.page === $scope.totalPages;\n  };\n\n  this.isActive = function(page) {\n    return this.page === page;\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.getAttributeValue = function(attribute, defaultValue, interpolate) {\n    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;\n  };\n\n  this.render = function() {\n    this.page = parseInt($scope.page, 10) || 1;\n    if (this.page > 0 && this.page <= $scope.totalPages) {\n      $scope.pages = this.getPages(this.page, $scope.totalPages);\n    }\n  };\n\n  $scope.selectPage = function(page) {\n    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {\n      $scope.page = page;\n      $scope.onSelectPage({ page: page });\n    }\n  };\n\n  $scope.$watch('page', function() {\n    self.render();\n  });\n\n  $scope.$watch('totalItems', function() {\n    $scope.totalPages = self.calculateTotalPages();\n  });\n\n  $scope.$watch('totalPages', function(value) {\n    setNumPages($scope.$parent, value); // Readonly variable\n\n    if ( self.page > value ) {\n      $scope.selectPage(value);\n    } else {\n      self.render();\n    }\n  });\n}])\n\n.constant('paginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {\n  return {\n    restrict: 'EA',\n    scope: {\n      page: '=',\n      totalItems: '=',\n      onSelectPage:' &'\n    },\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pagination.html',\n    replace: true,\n    link: function(scope, element, attrs, paginationCtrl) {\n\n      // Setup configuration parameters\n      var maxSize,\n      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),\n      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),\n      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),\n      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),\n      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),\n      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),\n      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);\n\n      paginationCtrl.init(config.itemsPerPage);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive, isDisabled) {\n        return {\n          number: number,\n          text: text,\n          active: isActive,\n          disabled: isDisabled\n        };\n      }\n\n      paginationCtrl.getPages = function(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );\n\n        // recompute if maxSize\n        if ( isMaxSized ) {\n          if ( rotate ) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, paginationCtrl.isActive(number), false);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if ( isMaxSized && ! rotate ) {\n          if ( startPage > 1 ) {\n            var previousPageSet = makePage(startPage - 1, '...', false, false);\n            pages.unshift(previousPageSet);\n          }\n\n          if ( endPage < totalPages ) {\n            var nextPageSet = makePage(endPage + 1, '...', false, false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        // Add previous & next links\n        if (directionLinks) {\n          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());\n          pages.unshift(previousPage);\n\n          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());\n          pages.push(nextPage);\n        }\n\n        // Add first & last links\n        if (boundaryLinks) {\n          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());\n          pages.unshift(firstPage);\n\n          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());\n          pages.push(lastPage);\n        }\n\n        return pages;\n      };\n    }\n  };\n}])\n\n.constant('pagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('pager', ['pagerConfig', function(config) {\n  return {\n    restrict: 'EA',\n    scope: {\n      page: '=',\n      totalItems: '=',\n      onSelectPage:' &'\n    },\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pager.html',\n    replace: true,\n    link: function(scope, element, attrs, paginationCtrl) {\n\n      // Setup configuration parameters\n      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),\n      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),\n      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);\n\n      paginationCtrl.init(config.itemsPerPage);\n\n      // Create page object used in template\n      function makePage(number, text, isDisabled, isPrevious, isNext) {\n        return {\n          number: number,\n          text: text,\n          disabled: isDisabled,\n          previous: ( align && isPrevious ),\n          next: ( align && isNext )\n        };\n      }\n\n      paginationCtrl.getPages = function(currentPage) {\n        return [\n          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),\n          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)\n        ];\n      };\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module( 'mm.foundation.tooltip', [ 'mm.foundation.position', 'mm.foundation.bindHtml' ] )\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider( '$tooltip', function () {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    animation: true,\n    popupDelay: 0\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'focus': 'blur'\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n  \n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['mm.foundation.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function( value ) {\n\t\tangular.extend( globalOptions, value );\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers ( triggers ) {\n    angular.extend( triggerMap, triggers );\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name){\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {\n    return function $tooltip ( type, prefix, defaultTriggerShow ) {\n      var options = angular.extend( {}, defaultOptions, globalOptions );\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers ( trigger ) {\n        var show = trigger || options.trigger || defaultTriggerShow;\n        var hide = triggerMap[show] || show;\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case( type );\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template = \n        '<div '+ directiveName +'-popup '+\n          'title=\"'+startSym+'tt_title'+endSym+'\" '+\n          'content=\"'+startSym+'tt_content'+endSym+'\" '+\n          'placement=\"'+startSym+'tt_placement'+endSym+'\" '+\n          'animation=\"tt_animation\" '+\n          'is-open=\"tt_isOpen\"'+\n          '>'+\n        '</div>';\n\n      return {\n        restrict: 'EA',\n        scope: true,\n        compile: function (tElem, tAttrs) {\n          var tooltipLinker = $compile( template );\n\n          return function link ( scope, element, attrs ) {\n            var tooltip;\n            var transitionTimeout;\n            var popupTimeout;\n            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;\n            var triggers = getTriggers( undefined );\n            var hasRegisteredTriggers = false;\n            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);\n\n            var positionTooltip = function (){\n              var position,\n                ttWidth,\n                ttHeight,\n                ttPosition;\n              // Get the position of the directive element.\n              position = appendToBody ? $position.offset( element ) : $position.position( element );\n\n              // Get the height and width of the tooltip so we can center it.\n              ttWidth = tooltip.prop( 'offsetWidth' );\n              ttHeight = tooltip.prop( 'offsetHeight' );\n\n              // Calculate the tooltip's top and left coordinates to center it with\n              // this directive.\n              switch ( scope.tt_placement ) {\n                case 'right':\n                  ttPosition = {\n                    top: position.top + position.height / 2 - ttHeight / 2,\n                    left: position.left + position.width + 10\n                  };\n                  break;\n                case 'bottom':\n                  ttPosition = {\n                    top: position.top + position.height + 10,\n                    left: position.left\n                  };\n                  break;\n                case 'left':\n                  ttPosition = {\n                    top: position.top + position.height / 2 - ttHeight / 2,\n                    left: position.left - ttWidth - 10\n                  };\n                  break;\n                default:\n                  ttPosition = {\n                    top: position.top - ttHeight - 10,\n                    left: position.left\n                  };\n                  break;\n              }\n\n              ttPosition.top += 'px';\n              ttPosition.left += 'px';\n\n              // Now set the calculated positioning.\n              tooltip.css( ttPosition );\n\n            };\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            scope.tt_isOpen = false;\n\n            function toggleTooltipBind () {\n              if ( ! scope.tt_isOpen ) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {\n                return;\n              }\n              if ( scope.tt_popupDelay ) {\n                popupTimeout = $timeout( show, scope.tt_popupDelay, false );\n                popupTimeout.then(function(reposition){reposition();});\n              } else {\n                show()();\n              }\n            }\n\n            function hideTooltipBind () {\n              scope.$apply(function () {\n                hide();\n              });\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n\n\n              // Don't show empty tooltips.\n              if ( ! scope.tt_content ) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // If there is a pending remove transition, we must cancel it, lest the\n              // tooltip be mysteriously removed.\n              if ( transitionTimeout ) {\n                $timeout.cancel( transitionTimeout );\n              }\n\n              // Set the initial positioning.\n              tooltip.css({ top: 0, left: 0, display: 'block' });\n\n              // Now we add it to the DOM because need some info about it. But it's not \n              // visible yet anyway.\n              if ( appendToBody ) {\n                  $document.find( 'body' ).append( tooltip );\n              } else {\n                element.after( tooltip );\n              }\n\n              positionTooltip();\n\n              // And show the tooltip.\n              scope.tt_isOpen = true;\n              scope.$digest(); // digest required as $apply is not called\n\n              // Return positioning function as promise callback for correct\n              // positioning after draw.\n              return positionTooltip;\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              // First things first: we don't show it anymore.\n              scope.tt_isOpen = false;\n\n              //if tooltip is going to be shown after delay, we must cancel this\n              $timeout.cancel( popupTimeout );\n\n              // And now we remove it from the DOM. However, if we have animation, we \n              // need to wait for it to expire beforehand.\n              // FIXME: this is a placeholder for a port of the transitions library.\n              if ( scope.tt_animation ) {\n                transitionTimeout = $timeout(removeTooltip, 500);\n              } else {\n                removeTooltip();\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                removeTooltip();\n              }\n              tooltip = tooltipLinker(scope, function () {});\n\n              // Get contents rendered into the tooltip\n              scope.$digest();\n            }\n\n            function removeTooltip() {\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n            }\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe( type, function ( val ) {\n              scope.tt_content = val;\n\n              if (!val && scope.tt_isOpen ) {\n                hide();\n              }\n            });\n\n            attrs.$observe( prefix+'Title', function ( val ) {\n              scope.tt_title = val;\n            });\n\n            attrs[prefix+'Placement'] = attrs[prefix+'Placement'] || null;\n\n            attrs.$observe( prefix+'Placement', function ( val ) {\n              scope.tt_placement = angular.isDefined( val ) && val ? val : options.placement;\n            });\n\n            attrs[prefix+'PopupDelay'] = attrs[prefix+'PopupDelay'] || null;\n\n            attrs.$observe( prefix+'PopupDelay', function ( val ) {\n              var delay = parseInt( val, 10 );\n              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;\n            });\n\n            var unregisterTriggers = function() {\n              if ( hasRegisteredTriggers ) {\n                if ( angular.isFunction( triggers.show ) ) {\n                  unregisterTriggerFunction();\n                } else {\n                  element.unbind( triggers.show, showTooltipBind );\n                  element.unbind( triggers.hide, hideTooltipBind );\n                }\n              }\n            };\n\n            var unregisterTriggerFunction = function () {};\n\n            attrs[prefix+'Trigger'] = attrs[prefix+'Trigger'] || null;\n\n            attrs.$observe( prefix+'Trigger', function ( val ) {\n              unregisterTriggers();\n              unregisterTriggerFunction();\n\n              triggers = getTriggers( val );\n\n              if ( angular.isFunction( triggers.show ) ) {\n                unregisterTriggerFunction = scope.$watch( function () {\n                  return triggers.show( scope, element, attrs );\n                }, function ( val ) {\n                  return val ? $timeout( show ) : $timeout( hide );\n                });\n              } else {\n                if ( triggers.show === triggers.hide ) {\n                  element.bind( triggers.show, toggleTooltipBind );\n                } else {\n                  element.bind( triggers.show, showTooltipBind );\n                  element.bind( triggers.hide, hideTooltipBind );\n                }\n              }\n\n              hasRegisteredTriggers = true;\n            });\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            attrs.$observe( prefix+'AppendToBody', function ( val ) {\n              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;\n            });\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if ( appendToBody ) {\n              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {\n              if ( scope.tt_isOpen ) {\n                hide();\n              }\n            });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              $timeout.cancel( transitionTimeout );\n              $timeout.cancel( popupTimeout );\n              unregisterTriggers();\n              unregisterTriggerFunction();\n              removeTooltip();\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n.directive( 'tooltipPopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );\n}])\n\n.directive( 'tooltipHtmlUnsafePopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'\n  };\n})\n\n.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html popovers, and selector delegatation.\n */\nangular.module( 'mm.foundation.popover', [ 'mm.foundation.tooltip' ] )\n\n.directive( 'popoverPopup', function () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html'\n  };\n})\n\n.directive( 'popover', [ '$tooltip', function ( $tooltip ) {\n  return $tooltip( 'popover', 'popover', 'click' );\n}]);\n\nangular.module('mm.foundation.progressbar', ['mm.foundation.transition'])\n\n.constant('progressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', '$transition', function($scope, $attrs, progressConfig, $transition) {\n    var self = this,\n        bars = [],\n        max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max,\n        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n    this.addBar = function(bar, element) {\n        var oldValue = 0, index = bar.$parent.$index;\n        if ( angular.isDefined(index) &&  bars[index] ) {\n            oldValue = bars[index].value;\n        }\n        bars.push(bar);\n\n        this.update(element, bar.value, oldValue);\n\n        bar.$watch('value', function(value, oldValue) {\n            if (value !== oldValue) {\n                self.update(element, value, oldValue);\n            }\n        });\n\n        bar.$on('$destroy', function() {\n            self.removeBar(bar);\n        });\n    };\n\n    // Update bar element width\n    this.update = function(element, newValue, oldValue) {\n        var percent = this.getPercentage(newValue);\n\n        if (animate) {\n            element.css('width', this.getPercentage(oldValue) + '%');\n            $transition(element, {width: percent + '%'});\n        } else {\n            element.css({'transition': 'none', 'width': percent + '%'});\n        }\n    };\n\n    this.removeBar = function(bar) {\n        bars.splice(bars.indexOf(bar), 1);\n    };\n\n    this.getPercentage = function(value) {\n        return Math.round(100 * value / max);\n    };\n}])\n\n.directive('progress', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        controller: 'ProgressController',\n        require: 'progress',\n        scope: {},\n        template: '<div class=\"progress\" ng-transclude></div>'\n        //templateUrl: 'template/progressbar/progress.html' // Works in AngularJS 1.2\n    };\n})\n\n.directive('bar', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        require: '^progress',\n        scope: {\n            value: '=',\n            type: '@'\n        },\n        templateUrl: 'template/progressbar/bar.html',\n        link: function(scope, element, attrs, progressCtrl) {\n            progressCtrl.addBar(scope, element);\n        }\n    };\n})\n\n.directive('progressbar', function() {\n    return {\n        restrict: 'EA',\n        replace: true,\n        transclude: true,\n        controller: 'ProgressController',\n        scope: {\n            value: '=',\n            type: '@'\n        },\n        templateUrl: 'template/progressbar/progressbar.html',\n        link: function(scope, element, attrs, progressCtrl) {\n            progressCtrl.addBar(scope, angular.element(element.children()[0]));\n        }\n    };\n});\n\nangular.module('mm.foundation.rating', [])\n\n.constant('ratingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null\n})\n\n.controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {\n\n  this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;\n  this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n  this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\n  this.createRateObjects = function(states) {\n    var defaultOptions = {\n      stateOn: this.stateOn,\n      stateOff: this.stateOff\n    };\n\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, defaultOptions, states[i]);\n    }\n    return states;\n  };\n\n  // Get objects used in template\n  $scope.range = angular.isDefined($attrs.ratingStates) ?  this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))): this.createRateObjects(new Array(this.maxRange));\n\n  $scope.rate = function(value) {\n    if ( $scope.value !== value && !$scope.readonly ) {\n      $scope.value = value;\n    }\n  };\n\n  $scope.enter = function(value) {\n    if ( ! $scope.readonly ) {\n      $scope.val = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.val = angular.copy($scope.value);\n    $scope.onLeave();\n  };\n\n  $scope.$watch('value', function(value) {\n    $scope.val = value;\n  });\n\n  $scope.readonly = false;\n  if ($attrs.readonly) {\n    $scope.$parent.$watch($parse($attrs.readonly), function(value) {\n      $scope.readonly = !!value;\n    });\n  }\n}])\n\n.directive('rating', function() {\n  return {\n    restrict: 'EA',\n    scope: {\n      value: '=',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true\n  };\n});\n\n\n/**\n * @ngdoc overview\n * @name mm.foundation.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module('mm.foundation.tabs', [])\n\n.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(tab) {\n    angular.forEach(tabs, function(tab) {\n      tab.active = false;\n    });\n    tab.active = true;\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    if (tabs.length === 1 || tab.active) {\n      ctrl.select(tab);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected\n    if (tab.active && tabs.length > 1) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name mm.foundation.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module=\"mm.foundation\">\n  <file name=\"index.html\">\n    <tabset>\n      <tab heading=\"Tab 1\"><b>First</b> Content!</tab>\n      <tab heading=\"Tab 2\"><i>Second</i> Content!</tab>\n    </tabset>\n    <hr />\n    <tabset vertical=\"true\">\n      <tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</tab>\n      <tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</tab>\n    </tabset>\n    <tabset justified=\"true\">\n      <tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</tab>\n      <tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</tab>\n    </tabset>\n  </file>\n</example>\n */\n.directive('tabset', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    scope: {},\n    controller: 'TabsetController',\n    templateUrl: 'template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n      scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name mm.foundation.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link mm.foundation.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link mm.foundation.tabs.directive:tabset tabset}.\n *\n * @example\n<example module=\"mm.foundation\">\n  <file name=\"index.html\">\n    <div ng-controller=\"TabsDemoCtrl\">\n      <button class=\"button small\" ng-click=\"items[0].active = true\">\n        Select item 1, using active binding\n      </button>\n      <button class=\"button small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <tabset>\n        <tab heading=\"Tab 1\">First Tab</tab>\n        <tab select=\"alertMe()\">\n          <tab-heading><i class=\"fa fa-bell\"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </tab>\n        <tab ng-repeat=\"item in items\"\n          heading=\"{{item.title}}\"\n          disabled=\"item.disabled\"\n          active=\"item.active\">\n          {{item.content}}\n        </tab>\n      </tabset>\n    </div>\n  </file>\n  <file name=\"script.js\">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert(\"You've selected the alert tab!\");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name mm.foundation.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link mm.foundation.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module=\"mm.foundation\">\n  <file name=\"index.html\">\n    <tabset>\n      <tab>\n        <tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </tab>\n      <tab>\n        <tab-heading><i class=\"fa fa-heart\"></i> Icon heading?!?</tab-heading>\n        That's right.\n      </tab>\n    </tabset>\n  </file>\n</example>\n */\n.directive('tab', ['$parse', function($parse) {\n  return {\n    require: '^tabset',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    compile: function(elm, attrs, transclude) {\n      return function postLink(scope, elm, attrs, tabsetCtrl) {\n        var getActive, setActive;\n        if (attrs.active) {\n          getActive = $parse(attrs.active);\n          setActive = getActive.assign;\n          scope.$parent.$watch(getActive, function updateActive(value, oldVal) {\n            // Avoid re-initializing scope.active as it is already initialized\n            // below. (watcher is called async during init with value ===\n            // oldVal)\n            if (value !== oldVal) {\n              scope.active = !!value;\n            }\n          });\n          scope.active = getActive(scope.$parent);\n        } else {\n          setActive = getActive = angular.noop;\n        }\n\n        scope.$watch('active', function(active) {\n          if( !angular.isFunction(setActive) ){\n            return;\n          }\n          // Note this watcher also initializes and assigns scope.active to the\n          // attrs.active expression.          \n          setActive(scope.$parent, active);\n          if (active) {\n            tabsetCtrl.select(scope);\n            scope.onSelect();\n          } else {\n            scope.onDeselect();\n          }\n        });\n\n        scope.disabled = false;\n        if ( attrs.disabled ) {\n          scope.$parent.$watch($parse(attrs.disabled), function(value) {\n            scope.disabled = !! value;\n          });\n        }\n\n        scope.select = function() {\n          if ( ! scope.disabled ) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on('$destroy', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we're inside a tab heading.\n        scope.$transcludeFn = transclude;\n      };\n    }\n  };\n}])\n\n.directive('tabHeadingTransclude', [function() {\n  return {\n    restrict: 'A',\n    require: '^tab',\n    link: function(scope, elm, attrs, tabCtrl) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n}])\n\n.directive('tabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^tabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.tabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n  function isTabHeading(node) {\n    return node.tagName &&  (\n      node.hasAttribute('tab-heading') ||\n      node.hasAttribute('data-tab-heading') ||\n      node.tagName.toLowerCase() === 'tab-heading' ||\n      node.tagName.toLowerCase() === 'data-tab-heading'\n    );\n  }\n})\n\n;\n\nangular.module(\"mm.foundation.topbar\", ['mm.foundation.mediaQueries'])\n.factory('closest', [function() {\n  return function(el, selector) {\n    var matchesSelector = function (node, selector) {\n      var nodes = (node.parentNode || node.document).querySelectorAll(selector);\n      var i = -1;\n      while (nodes[++i] && nodes[i] != node){}\n      return !!nodes[i];\n    };\n\n    var element = el[0];\n    while (element) {\n      if (matchesSelector(element, selector)) {\n        return angular.element(element);\n      } else {\n        element = element.parentElement;\n      }\n    }\n    return false;\n  };\n}])\n.directive('topBar', ['$timeout','$compile', '$window', '$document', 'mediaQueries',\n  function($timeout, $compile, $window, $document, mediaQueries) {\n    return {\n      scope: {\n        stickyClass : '@',\n        backText: '@',\n        stickyOn : '=',\n        customBackText: '=',\n        isHover: '=',\n        mobileShowParentLink: '=',\n        scrolltop : '=',\n      },\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/topbar/top-bar.html',\n      transclude: true,\n      controller: ['$window', '$scope', 'closest', function($window, $scope, closest) {\n        $scope.settings = {};\n        $scope.settings.stickyClass = $scope.stickyClass || 'sticky';\n        $scope.settings.backText = $scope.backText || 'Back';\n        $scope.settings.stickyOn = $scope.stickyOn || 'all';\n\n        $scope.settings.customBackText = $scope.customBackText === undefined ? true : $scope.customBackText;\n        $scope.settings.isHover = $scope.isHover === undefined ? true : $scope.isHover;\n        $scope.settings.mobileShowParentLink = $scope.mobileShowParentLink === undefined ? true : $scope.mobileShowParentLink;\n        $scope.settings.scrolltop = $scope.scrolltop === undefined ? true : $scope.scrolltop; // jump to top when sticky nav menu toggle is clicked\n\n        this.settings = $scope.settings;\n\n        $scope.index = 0;\n\n        var outerHeight = function(el) {\n          var height = el.offsetHeight;\n          var style = el.currentStyle || getComputedStyle(el);\n\n          height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n          return height;\n        };\n\n\n        var sections = [];\n\n        this.addSection = function(section) {\n          sections.push(section);\n        };\n\n        this.removeSection = function(section) {\n          var index = sections.indexOf(section);\n          if (index > -1) {\n            sections.splice(index, 1);\n          }\n        };\n\n        var dir = /rtl/i.test($document.find('html').attr('dir')) ? 'right' : 'left';\n\n        $scope.$watch('index', function(index) {\n          for(var i = 0; i < sections.length; i++){\n            sections[i].move(dir, index);\n          }\n        });\n\n        this.toggle = function(on) {\n          $scope.toggle(on);\n          for(var i = 0; i < sections.length; i++){\n            sections[i].reset();\n          }\n          $scope.index = 0;\n          $scope.height = '';\n          $scope.$apply();\n        };\n\n        this.back = function(event) {\n          if($scope.index < 1 || !mediaQueries.topbarBreakpoint()){\n            return;\n          }\n\n          var $link = angular.element(event.currentTarget);\n          var $movedLi = closest($link, 'li.moved');\n          var $previousLevelUl = $movedLi.parent();\n          $scope.index = $scope.index -1;\n\n          if($scope.index === 0){\n            $scope.height = '';\n          } else {\n            $scope.height = $scope.originalHeight + outerHeight($previousLevelUl[0]);\n          }\n\n          $timeout(function() {\n            $movedLi.removeClass('moved');\n          }, 300);\n        };\n\n        this.forward = function(event) {\n          if(!mediaQueries.topbarBreakpoint()){\n            return false;\n          }\n\n          var $link = angular.element(event.currentTarget);\n          var $selectedLi = closest($link, 'li');\n          $selectedLi.addClass('moved');\n          $scope.height = $scope.originalHeight + outerHeight($link.parent()[0].querySelector('ul'));\n          $scope.index = $scope.index + 1;\n          $scope.$apply();\n        };\n\n      }],\n      link: function(scope, element, attrs) {\n        var topbar = scope.topbar = element;\n        var topbarContainer = topbar.parent();\n        var body = angular.element($document[0].querySelector('body'));\n        var lastBreakpoint = mediaQueries.topbarBreakpoint();\n\n        var isSticky = scope.isSticky = function() {\n          var sticky = topbarContainer.hasClass(scope.settings.stickyClass);\n          if (sticky && scope.settings.stickyOn === 'all') {\n            return true;\n          } else if (sticky && mediaQueries.small() && scope.settings.stickyOn === 'small') {\n            return true;\n          } else if (sticky && mediaQueries.medium() && scope.settings.stickyOn === 'medium') {\n            return true;\n          } else if (sticky && mediaQueries.large() && scope.settings.stickyOn === 'large') {\n            return true;\n          }\n          return false;\n        };\n\n        var updateStickyPositioning = function() {\n          if (!scope.stickyTopbar || !scope.isSticky()) {\n            return;\n          }\n\n          var distance = stickyoffset;\n\n          if ($window.pageYOffset > distance && !topbarContainer.hasClass('fixed')) {\n            topbarContainer.addClass('fixed');\n            body.css('padding-top', scope.originalHeight + 'px');\n          } else if ($window.pageYOffset <= distance && topbarContainer.hasClass('fixed')) {\n            topbarContainer.removeClass('fixed');\n            body.css('padding-top', '');\n          }\n        };\n\n        var onResize = function() {\n          var currentBreakpoint = mediaQueries.topbarBreakpoint();\n          if(lastBreakpoint === currentBreakpoint){\n            return;\n          }\n          lastBreakpoint = mediaQueries.topbarBreakpoint();\n\n          topbar.removeClass('expanded');\n          topbar.parent().removeClass('expanded');\n          scope.height = '';\n\n          var sections = angular.element(topbar[0].querySelectorAll('section'));\n          angular.forEach(sections, function(section) {\n            angular.element(section.querySelectorAll('li.moved')).removeClass('moved');\n          });\n\n          scope.$apply();\n        };\n\n        var onScroll = function() {\n          updateStickyPositioning();\n          scope.$apply();\n        };\n\n        scope.toggle = function(on) {\n          if(!mediaQueries.topbarBreakpoint()){\n            return false;\n          }\n\n          var expand = (on === undefined) ? !topbar.hasClass('expanded') : on;\n\n          if (expand) {\n            topbar.addClass('expanded');\n          }\n          else {\n            topbar.removeClass('expanded');\n          }\n\n          if (scope.settings.scrolltop) {\n            if (!expand && topbar.hasClass('fixed')) {\n              topbar.parent().addClass('fixed');\n              topbar.removeClass('fixed');\n              body.css('padding-top', scope.originalHeight + 'px');\n            } else if (expand && topbar.parent().hasClass('fixed')) {\n              topbar.parent().removeClass('fixed');\n              topbar.addClass('fixed');\n              body.css('padding-top', '');\n              $window.scrollTo(0,0);\n            }\n          } else {\n            if(isSticky()) {\n              topbar.parent().addClass('fixed');\n            }\n\n            if(topbar.parent().hasClass('fixed')) {\n              if (!expand) {\n                topbar.removeClass('fixed');\n                topbar.parent().removeClass('expanded');\n                updateStickyPositioning();\n              } else {\n                topbar.addClass('fixed');\n                topbar.parent().addClass('expanded');\n                body.css('padding-top', scope.originalHeight + 'px');\n              }\n            }\n          }\n        };\n\n        if(topbarContainer.hasClass('fixed') || isSticky() ) {\n          scope.stickyTopbar = true;\n          scope.height = topbarContainer[0].offsetHeight;\n          var stickyoffset = topbarContainer[0].getBoundingClientRect().top + $window.pageYOffset;\n        } else {\n          scope.height = topbar[0].offsetHeight;\n        }\n\n        scope.originalHeight = scope.height;\n\n        scope.$watch('height', function(h) {\n          if(h){\n            topbar.css('height', h + 'px');\n          } else {\n            topbar.css('height', '');\n          }\n        });\n\n        angular.element($window).bind('resize', onResize);\n        angular.element($window).bind('scroll', onScroll);\n\n        scope.$on('$destroy', function() {\n          angular.element($window).unbind('scroll', onResize);\n          angular.element($window).unbind('resize', onScroll);\n        });\n\n        if (topbarContainer.hasClass('fixed')) {\n          body.css('padding-top', scope.originalHeight + 'px');\n        }\n      }\n    };\n  }]\n)\n.directive('toggleTopBar', ['closest', function (closest) {\n  return {\n    scope: {},\n    require: '^topBar',\n    restrict: 'A',\n    replace: true,\n    templateUrl: 'template/topbar/toggle-top-bar.html',\n    transclude: true,\n    link: function(scope, element, attrs, topBar) {\n      element.bind('click', function(event) {\n        var li = closest(angular.element(event.currentTarget), 'li');\n        if(!li.hasClass('back') && !li.hasClass('has-dropdown')) {\n          topBar.toggle();\n        }\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click');\n      });\n    }\n  };\n}])\n.directive('topBarSection', ['$compile', 'closest', function($compile, closest) {\n  return {\n    scope: {},\n    require: '^topBar',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/topbar/top-bar-section.html',\n    transclude: true,\n    link: function(scope, element, attrs, topBar) {\n      var section = element;\n\n      scope.reset = function() {\n        angular.element(section[0].querySelectorAll('li.moved')).removeClass('moved');\n      };\n\n      scope.move = function(dir, index) {\n        if(dir === 'left'){\n          section.css({\"left\": index * -100 + '%'});\n        }\n        else {\n          section.css({\"right\": index * -100 + '%'});\n        }\n      };\n\n      topBar.addSection(scope);\n\n      scope.$on(\"$destroy\", function() {\n        topBar.removeSection(scope);\n      });\n\n      // Top level links close menu on click\n      var links = section[0].querySelectorAll('li>a');\n      angular.forEach(links, function(link) {\n        var $link = angular.element(link);\n        var li = closest($link, 'li');\n        if (li.hasClass('has-dropdown') || li.hasClass('back') || li.hasClass('title')) {\n          return;\n        }\n\n        $link.bind('click', function() {\n          topBar.toggle(false);\n        });\n\n        scope.$on('$destroy', function() {\n          $link.bind('click');\n        });\n      });\n    }\n  };\n}])\n.directive('hasDropdown', ['mediaQueries', function (mediaQueries) {\n  return {\n    scope: {},\n    require: '^topBar',\n    restrict: 'A',\n    templateUrl: 'template/topbar/has-dropdown.html',\n    replace: true,\n    transclude: true,\n    link: function(scope, element, attrs, topBar) {\n      scope.triggerLink = element.children('a')[0];\n\n      var $link = angular.element(scope.triggerLink);\n\n      $link.bind('click', function(event) {\n        topBar.forward(event);\n      });\n      scope.$on('$destroy', function() {\n        $link.unbind('click');\n      });\n\n      element.bind('mouseenter', function() {\n        if(topBar.settings.isHover && !mediaQueries.topbarBreakpoint()){\n          element.addClass('not-click');\n        }\n      });\n      element.bind('click', function(event) {\n        if(!topBar.settings.isHover && !mediaQueries.topbarBreakpoint()){\n          element.toggleClass('not-click');\n        }\n      });\n\n      element.bind('mouseleave', function() {\n        element.removeClass('not-click');\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click');\n        element.unbind('mouseenter');\n        element.unbind('mouseleave');\n      });\n    },\n    controller: ['$window', '$scope', function($window, $scope) {\n      this.triggerLink = $scope.triggerLink;\n    }]\n  };\n}])\n.directive('topBarDropdown', ['$compile', function($compile) {\n  return {\n    scope: {},\n    require: ['^topBar', '^hasDropdown'],\n    restrict: 'A',\n    replace: true,\n    templateUrl: 'template/topbar/top-bar-dropdown.html',\n    transclude: true,\n    link: function(scope, element, attrs, ctrls) {\n      var topBar = ctrls[0];\n      var hasDropdown = ctrls[1];\n      var $link = angular.element(hasDropdown.triggerLink);\n      var url = $link.attr('href');\n      var $titleLi;\n\n      scope.linkText = $link.text();\n\n      scope.back = function(event) {\n        topBar.back(event);\n      };\n\n      // Add back link\n      if (topBar.settings.customBackText) {\n        scope.backText = topBar.settings.backText;\n      } else {\n        scope.backText = '&laquo; ' + $link.html();\n      }\n\n      if (topBar.settings.mobileShowParentLink && url && url.length > 1) {\n        $titleLi = angular.element('<li class=\"title back js-generated\">' +\n            '<h5><a href=\"#\" ng-click=\"back($event);\">{{backText}}</a></h5></li>' +\n            '<li><a class=\"parent-link js-generated\" href=\"' +\n            url + '\">{{linkText}}</a></li>');\n      } else {\n        $titleLi = angular.element('<li class=\"title back js-generated\">' +\n            '<h5><a href=\"\" ng-click=\"back($event);\">{{backText}}</a></h5></li>');\n      }\n\n      $compile($titleLi)(scope);\n      element.prepend($titleLi);\n    }\n  };\n}]);\n\nangular.module( 'mm.foundation.tour', [ 'mm.foundation.position', 'mm.foundation.tooltip' ] )\n\n.service( '$tour', [ '$window', function ( $window ) {\n  var currentIndex = getStoredCurrentStep();\n  var ended = false;\n  var steps = {};\n\n  function getStoredCurrentStep() {\n    try {\n      return parseInt( $window.localStorage.getItem( 'mm.tour.step' ), 10 );\n    } catch(e) {\n      if (e.name !== \"SecurityError\") {\n        throw e;\n      }\n    }\n  }\n\n  function storeCurrentStep() {\n    try {\n      $window.localStorage.setItem( 'mm.tour.step', currentIndex );\n    } catch(e) {\n      if (e.name !== \"SecurityError\") {\n        throw e;\n      }\n    }\n  }\n\n  function setCurrentStep(step) {\n    currentIndex = step;\n    storeCurrentStep();\n  }\n\n  this.add = function ( index, attrs ) {\n    steps[ index ] = attrs;\n  };\n\n  this.has = function ( index ) {\n    return !!steps[ index ];\n  };\n\n  this.isActive = function () {\n    return currentIndex > 0;\n  };\n\n  this.current = function ( index ) {\n    if ( index ) {\n      setCurrentStep( currentIndex );\n    } else {\n      return currentIndex;\n    }\n  };\n\n  this.start = function () {\n    setCurrentStep( 1 );\n  };\n\n  this.next = function () {\n    setCurrentStep( currentIndex + 1 );\n  };\n\n  this.end = function () {\n    setCurrentStep( 0 );\n  };\n}])\n\n.directive( 'stepTextPopup', ['$tour', function ( $tour ) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tour/tour.html',\n    link: function (scope, element) {\n      scope.isLastStep = function () {\n        return !$tour.has( $tour.current() + 1 );\n      };\n\n      scope.endTour = function () {\n        element.remove();\n        $tour.end();\n      };\n\n      scope.nextStep = function () {\n        element.remove();\n        $tour.next();\n      };\n\n      scope.$on('$locationChangeSuccess', scope.endTour);\n    }\n  };\n}])\n\n.directive( 'stepText', [ '$position', '$tooltip', '$tour', '$window', function ( $position, $tooltip, $tour, $window ) {\n  function isElementInViewport( element ) {\n    var rect = element[0].getBoundingClientRect();\n\n    return (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= ($window.innerHeight - 80) &&\n      rect.right <= $window.innerWidth\n    );\n  }\n\n  function show( scope, element, attrs ) {\n    var index = parseInt( attrs.stepIndex, 10);\n\n    if ( $tour.isActive() && index ) {\n      $tour.add( index, attrs );\n\n      if ( index === $tour.current() ) {\n        if ( !isElementInViewport( element ) ) {\n          var offset = $position.offset( element );\n          $window.scrollTo( 0, offset.top - $window.innerHeight / 2 );\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return $tooltip( 'stepText', 'step', show );\n}]);\n\nangular.module('mm.foundation.typeahead', ['mm.foundation.position', 'mm.foundation.bindHtml'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('typeaheadParser', ['$parse', function ($parse) {\n\n  //                      00000111000000000000022200000000000000003333333333333330000000000044000\n  var TYPEAHEAD_REGEXP = /^\\s*(.*?)(?:\\s+as\\s+(.*?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+(.*)$/;\n\n  return {\n    parse:function (input) {\n\n      var match = input.match(TYPEAHEAD_REGEXP);\n      if (!match) {\n        throw new Error(\n          \"Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'\" +\n            \" but got '\" + input + \"'.\");\n      }\n\n      return {\n        itemName:match[3],\n        source:$parse(match[4]),\n        viewMapper:$parse(match[2] || match[1]),\n        modelMapper:$parse(match[1])\n      };\n    }\n  };\n}])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',\n    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\n\n  var HOT_KEYS = [9, 13, 27, 38, 40];\n\n  return {\n    require:'ngModel',\n    link:function (originalScope, element, attrs, modelCtrl) {\n\n      //SUPPORTED ATTRIBUTES (OPTIONS)\n\n      //minimal no of characters that needs to be entered before typeahead kicks-in\n      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\n\n      //minimal wait time after last character typed before typehead kicks-in\n      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n      //should it restrict model values to the ones selected from the popup only?\n      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n      //binding to a variable that indicates if matches are being retrieved asynchronously\n      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n      //a callback executed when a match is selected\n      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n      var appendToBody =  attrs.typeaheadAppendToBody ? $parse(attrs.typeaheadAppendToBody) : false;\n\n      //INTERNAL VARIABLES\n\n      //model setter executed upon match selection\n      var $setModelValue = $parse(attrs.ngModel).assign;\n\n      //expressions used by typeahead\n      var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n      var hasFocus;\n\n      //pop-up element used to display matches\n      var popUpEl = angular.element('<div typeahead-popup></div>');\n      popUpEl.attr({\n        matches: 'matches',\n        active: 'activeIdx',\n        select: 'select(activeIdx)',\n        query: 'query',\n        position: 'position'\n      });\n      //custom item template\n      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n      }\n\n      //create a child scope for the typeahead directive so we are not polluting original scope\n      //with typeahead-specific data (matches, query etc.)\n      var scope = originalScope.$new();\n      originalScope.$on('$destroy', function(){\n        scope.$destroy();\n      });\n\n      var resetMatches = function() {\n        scope.matches = [];\n        scope.activeIdx = -1;\n      };\n\n      var getMatchesAsync = function(inputValue) {\n\n        var locals = {$viewValue: inputValue};\n        isLoadingSetter(originalScope, true);\n        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\n          //it might happen that several async queries were in progress if a user were typing fast\n          //but we are interested only in responses that correspond to the current view value\n          if (inputValue === modelCtrl.$viewValue && hasFocus) {\n            if (matches.length > 0) {\n\n              scope.activeIdx = 0;\n              scope.matches.length = 0;\n\n              //transform labels\n              for(var i=0; i<matches.length; i++) {\n                locals[parserResult.itemName] = matches[i];\n                scope.matches.push({\n                  label: parserResult.viewMapper(scope, locals),\n                  model: matches[i]\n                });\n              }\n\n              scope.query = inputValue;\n              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n              //due to other elements being rendered\n              scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n              scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n            } else {\n              resetMatches();\n            }\n            isLoadingSetter(originalScope, false);\n          }\n        }, function(){\n          resetMatches();\n          isLoadingSetter(originalScope, false);\n        });\n      };\n\n      resetMatches();\n\n      //we need to propagate user's query so we can higlight matches\n      scope.query = undefined;\n\n      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n      var timeoutPromise;\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function (inputValue) {\n\n        if (inputValue && inputValue.length >= minSearch) {\n          if (waitTime > 0) {\n            if (timeoutPromise) {\n              $timeout.cancel(timeoutPromise);//cancel previous timeout\n            }\n            timeoutPromise = $timeout(function () {\n              getMatchesAsync(inputValue);\n            }, waitTime);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity('editable', true);\n            return inputValue;\n          } else {\n            modelCtrl.$setValidity('editable', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function (modelValue) {\n\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        if (inputFormatter) {\n\n          locals['$model'] = modelValue;\n          return inputFormatter(originalScope, locals);\n\n        } else {\n\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n\n      scope.select = function (activeIdx) {\n        //called from within the $digest() cycle\n        var locals = {};\n        var model, item;\n\n        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n        model = parserResult.modelMapper(originalScope, locals);\n        $setModelValue(originalScope, model);\n        modelCtrl.$setValidity('editable', true);\n\n        onSelectCallback(originalScope, {\n          $item: item,\n          $model: model,\n          $label: parserResult.viewMapper(originalScope, locals)\n        });\n\n        resetMatches();\n\n        //return focus to the input element if a mach was selected via a mouse click event\n        element[0].focus();\n      };\n\n      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n      element.bind('keydown', function (evt) {\n\n        //typeahead is open and an \"interesting\" key was pressed\n        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n          return;\n        }\n\n        evt.preventDefault();\n\n        if (evt.which === 40) {\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n\n        } else if (evt.which === 38) {\n          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n\n        } else if (evt.which === 13 || evt.which === 9) {\n          scope.$apply(function () {\n            scope.select(scope.activeIdx);\n          });\n\n        } else if (evt.which === 27) {\n          evt.stopPropagation();\n\n          resetMatches();\n          scope.$digest();\n        }\n      });\n\n      element.bind('blur', function (evt) {\n        hasFocus = false;\n      });\n\n      element.bind('focus', function (evt) {\n        hasFocus = true;\n      });\n\n      // Keep reference to click handler to unbind it.\n      var dismissClickHandler = function (evt) {\n        if (element[0] !== evt.target) {\n          resetMatches();\n          scope.$digest();\n        }\n      };\n\n      $document.bind('click', dismissClickHandler);\n\n      originalScope.$on('$destroy', function(){\n        $document.unbind('click', dismissClickHandler);\n      });\n\n      var $popup = $compile(popUpEl)(scope);\n      if ( appendToBody ) {\n        $document.find('body').append($popup);\n      } else {\n        element.after($popup);\n      }\n    }\n  };\n\n}])\n\n  .directive('typeaheadPopup', function () {\n    return {\n      restrict:'EA',\n      scope:{\n        matches:'=',\n        query:'=',\n        active:'=',\n        position:'=',\n        select:'&'\n      },\n      replace:true,\n      templateUrl:'template/typeahead/typeahead-popup.html',\n      link:function (scope, element, attrs) {\n\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function () {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function (matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function (matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function (activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {\n    return {\n      restrict:'EA',\n      scope:{\n        index:'=',\n        match:'=',\n        query:'='\n      },\n      link:function (scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){\n           element.replaceWith($compile(tplContent.trim())(scope));\n        });\n      }\n    };\n  }])\n\n  .filter('typeaheadHighlight', function() {\n\n    function escapeRegexp(queryToEscape) {\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n    }\n\n    return function(matchItem, query) {\n      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;\n    };\n  });\n\nangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion-group.html\",\n    \"<dd>\\n\" +\n    \"  <a ng-click=\\\"isOpen = !isOpen\\\" ng-class=\\\"{ active: isOpen }\\\"  accordion-transclude=\\\"heading\\\">{{heading}}</a>\\n\" +\n    \"  <div class=\\\"content\\\" ng-style=\\\"isOpen ? {display: 'block'} : {}\\\" ng-transclude></div>\\n\" +\n    \"</dd>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion.html\",\n    \"<dl class=\\\"accordion\\\" ng-transclude></dl>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/alert/alert.html\",\n    \"<div class='alert-box' ng-class='(type || \\\"\\\")'>\\n\" +\n    \"  <span ng-transclude></span>\\n\" +\n    \"  <a ng-show='closeable' class='close' ng-click='close()'>&times;</a>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/backdrop.html\",\n    \"<div class=\\\"reveal-modal-bg fade\\\" ng-class=\\\"{in: animate}\\\" ng-click=\\\"close($event)\\\" style=\\\"display: block\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/window.html\",\n    \"<div tabindex=\\\"-1\\\" class=\\\"reveal-modal fade {{ windowClass }}\\\"\\n\" +\n    \"  ng-class=\\\"{in: animate}\\\" style=\\\"display: block; visibility: visible\\\">\\n\" +\n    \"  <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pager.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-repeat=\\\"page in pages\\\" class=\\\"arrow\\\" ng-class=\\\"{unavailable: page.disabled, left: page.previous, right: page.next}\\\"><a ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-repeat=\\\"page in pages\\\" ng-class=\\\"{arrow: $first || $last, current: page.active, unavailable: page.disabled}\\\"><a ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-html-unsafe-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-html-unsafe-popup.html\",\n    \"<span class=\\\"tooltip tip-{{placement}}\\\"\\n\" +\n    \"  ng-class=\\\"{ in: isOpen(), fade: animation() }\\\"\\n\" +\n    \"  style=\\\"width: auto\\\">\\n\" +\n    \"  <span bind-html-unsafe=\\\"content\\\"></span>\\n\" +\n    \"  <span class=\\\"nub\\\"></span>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n    \"<span class=\\\"tooltip tip-{{placement}}\\\"\\n\" +\n    \"  ng-class=\\\"{ in: isOpen(), fade: animation() }\\\"\\n\" +\n    \"  style=\\\"width: auto\\\">\\n\" +\n    \"  <span ng-bind=\\\"content\\\"></span>\\n\" +\n    \"  <span class=\\\"nub\\\"></span>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover.html\",\n    \"<div class=\\\"joyride-tip-guide\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n    \"  <span class=\\\"joyride-nub\\\" ng-class=\\\"{\\n\" +\n    \"    bottom: placement === 'top',\\n\" +\n    \"    left: placement === 'right',\\n\" +\n    \"    right: placement === 'left',\\n\" +\n    \"    top: placement === 'bottom'\\n\" +\n    \"  }\\\"></span>\\n\" +\n    \"  <div class=\\\"joyride-content-wrapper\\\">\\n\" +\n    \"    <h4 ng-bind=\\\"title\\\" ng-show=\\\"title\\\"></h4>\\n\" +\n    \"    <p ng-bind=\\\"content\\\"></p>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/bar.html\",\n    \"<span class=\\\"meter\\\" ng-transclude></span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-class=\\\"type\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\" ng-class=\\\"type\\\">\\n\" +\n    \"  <span class=\\\"meter\\\" ng-transclude></span>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\">\\n\" +\n    \"  <i ng-repeat=\\\"r in range\\\" ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"fa\\\"\\n\" +\n    \"    ng-class=\\\"$index < val && (r.stateOn || 'fa-star') || (r.stateOff || 'fa-star-o')\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tab.html\",\n    \"<dd ng-class=\\\"{active: active}\\\">\\n\" +\n    \"  <a ng-click=\\\"select()\\\" tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</dd>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tabset.html\",\n    \"<div class=\\\"tabbable\\\">\\n\" +\n    \"  <dl class=\\\"tabs\\\" ng-class=\\\"{'vertical': vertical}\\\" ng-transclude></dl>\\n\" +\n    \"  <div class=\\\"tabs-content\\\" ng-class=\\\"{'vertical': vertical}\\\">\\n\" +\n    \"    <div class=\\\"content\\\" \\n\" +\n    \"      ng-repeat=\\\"tab in tabs\\\" \\n\" +\n    \"      ng-class=\\\"{active: tab.active}\\\">\\n\" +\n    \"      <div tab-content-transclude=\\\"tab\\\"></div>\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/topbar/has-dropdown.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/topbar/has-dropdown.html\",\n    \"<li class=\\\"has-dropdown\\\" ng-transclude></li>\");\n}]);\n\nangular.module(\"template/topbar/toggle-top-bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/topbar/toggle-top-bar.html\",\n    \"<li class=\\\"toggle-topbar menu-icon\\\" ng-transclude></li>\");\n}]);\n\nangular.module(\"template/topbar/top-bar-dropdown.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/topbar/top-bar-dropdown.html\",\n    \"<ul class=\\\"dropdown\\\" ng-transclude></ul>\");\n}]);\n\nangular.module(\"template/topbar/top-bar-section.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/topbar/top-bar-section.html\",\n    \"<section class=\\\"top-bar-section\\\" ng-transclude></section>\");\n}]);\n\nangular.module(\"template/topbar/top-bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/topbar/top-bar.html\",\n    \"<nav class=\\\"top-bar\\\" ng-transclude></nav>\");\n}]);\n\nangular.module(\"template/tour/tour.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tour/tour.html\",\n    \"<div class=\\\"joyride-tip-guide\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\n    \"  <span class=\\\"joyride-nub\\\" ng-class=\\\"{\\n\" +\n    \"    bottom: placement === 'top',\\n\" +\n    \"    left: placement === 'right',\\n\" +\n    \"    right: placement === 'left',\\n\" +\n    \"    top: placement === 'bottom'\\n\" +\n    \"  }\\\"></span>\\n\" +\n    \"  <div class=\\\"joyride-content-wrapper\\\">\\n\" +\n    \"    <h4 ng-bind=\\\"title\\\" ng-show=\\\"title\\\"></h4>\\n\" +\n    \"    <p ng-bind=\\\"content\\\"></p>\\n\" +\n    \"    <a class=\\\"small button joyride-next-tip\\\" ng-show=\\\"!isLastStep()\\\" ng-click=\\\"nextStep()\\\">Next</a>\\n\" +\n    \"    <a class=\\\"small button joyride-next-tip\\\" ng-show=\\\"isLastStep()\\\" ng-click=\\\"endTour()\\\">End</a>\\n\" +\n    \"    <a class=\\\"joyride-close-tip\\\" ng-click=\\\"endTour()\\\">&times;</a>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n    \"<a tabindex=\\\"-1\\\" bind-html-unsafe=\\\"match.label | typeaheadHighlight:query\\\"></a>\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"f-dropdown\\\" ng-style=\\\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\">\\n\" +\n    \"        <div typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"cgNotify\",[]).factory(\"notify\",[\"$timeout\",\"$http\",\"$compile\",\"$templateCache\",\"$rootScope\",function(a,b,c,d,e){var f=10,g=15,h=1e4,i=\"angular-notify.html\",j=\"center\",k=document.body,l=0,m=[],n=[],o=function(o){\"object\"!=typeof o&&(o={message:o}),o.duration=o.duration?o.duration:h,o.templateUrl=o.templateUrl?o.templateUrl:i,o.container=o.container?o.container:k,o.classes=o.classes?o.classes:\"\";var p=o.scope?o.scope.$new():e.$new();if(p.$position=o.position?o.position:j,p.$message=o.message,p.$classes=o.classes,p.$messageTemplate=o.messageTemplate,l>0)for(var q=n.length+1-l,r=0;q>r;r++)n[r].$close();b.get(o.templateUrl,{cache:d}).success(function(b){var d=c(b)(p);if(d.bind(\"webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd\",function(a){(\"opacity\"===a.propertyName||0===a.currentTarget.style.opacity||a.originalEvent&&\"opacity\"===a.originalEvent.propertyName)&&(d.remove(),m.splice(m.indexOf(d),1),n.splice(n.indexOf(p),1),i())}),o.messageTemplate){for(var e,h=0;h<d.children().length;h++)if(angular.element(d.children()[h]).hasClass(\"cg-notify-message-template\")){e=angular.element(d.children()[h]);break}if(!e)throw new Error(\"cgNotify could not find the .cg-notify-message-template element in \"+o.templateUrl+\".\");e.append(c(o.messageTemplate)(p))}angular.element(o.container).append(d),m.push(d),\"center\"===p.$position&&a(function(){p.$centerMargin=\"-\"+d[0].offsetWidth/2+\"px\"}),p.$close=function(){d.css(\"opacity\",0).attr(\"data-closing\",\"true\"),i()};var i=function(){for(var a=0,b=f,c=m.length-1;c>=0;c--){var d=10,e=m[c],h=e[0].offsetHeight,i=b+h+d;e.attr(\"data-closing\")?i+=20:b+=h+g,e.css(\"top\",i+\"px\").css(\"margin-top\",\"-\"+(h+d)+\"px\").css(\"visibility\",\"visible\"),a++}};a(function(){i()}),o.duration>0&&a(function(){p.$close()},o.duration)}).error(function(a){throw new Error(\"Template specified for cgNotify (\"+o.templateUrl+\") could not be loaded. \"+a)});var s={};return s.close=function(){p.$close&&p.$close()},Object.defineProperty(s,\"message\",{get:function(){return p.$message},set:function(a){p.$message=a}}),n.push(p),s};return o.config=function(a){f=angular.isUndefined(a.startTop)?f:a.startTop,g=angular.isUndefined(a.verticalSpacing)?g:a.verticalSpacing,h=angular.isUndefined(a.duration)?h:a.duration,i=a.templateUrl?a.templateUrl:i,j=angular.isUndefined(a.position)?j:a.position,k=a.container?a.container:k,l=a.maximumOpen?a.maximumOpen:l},o.closeAll=function(){for(var a=m.length-1;a>=0;a--){var b=m[a];b.css(\"opacity\",0)}},o}]),angular.module(\"cgNotify\").run([\"$templateCache\",function(a){\"use strict\";a.put(\"angular-notify.html\",\"<div class=\\\"cg-notify-message\\\" ng-class=\\\"[$classes, \\n    $position === 'center' ? 'cg-notify-message-center' : '',\\n    $position === 'left' ? 'cg-notify-message-left' : '',\\n    $position === 'right' ? 'cg-notify-message-right' : '']\\\"\\n    ng-style=\\\"{'margin-left': $centerMargin}\\\">\\n\\n    <div ng-show=\\\"!$messageTemplate\\\">\\n        {{$message}}\\n    </div>\\n\\n\"+'    <div ng-show=\"$messageTemplate\" class=\"cg-notify-message-template\">\\n        \\n    </div>\\n\\n    <button type=\"button\" class=\"cg-notify-close\" ng-click=\"$close()\">\\n        <span aria-hidden=\"true\">&times;</span>\\n        <span class=\"cg-notify-sr-only\">Close</span>\\n    </button>\\n\\n</div>')}]);\n/*\n The MIT License (MIT)\n\n Copyright (c) 2014 Muhammed Ashik\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n\n/*jshint indent: 2 */\n/*global angular: false */\n\n(function () {\n  'use strict';\n  angular.module('as.sortable', [])\n      .constant('sortableConfig', {\n        itemClass: 'as-sortable-item',\n        handleClass: 'as-sortable-item-handle',\n        placeHolderClass: 'as-sortable-placeholder',\n        dragClass: 'as-sortable-drag',\n        hiddenClass: 'as-sortable-hidden',\n        dragging: 'as-sortable-dragging'\n      });\n}());\n\n/*jshint indent: 2 */\n/*global angular: false */\n\n(function () {\n  'use strict';\n\n  var mainModule = angular.module('as.sortable');\n\n  /**\n   * Helper factory for sortable.\n   */\n  mainModule.factory('$helper', ['$document', '$window',\n    function ($document, $window) {\n      return {\n\n        /**\n         * Get the height of an element.\n         *\n         * @param {Object} element Angular element.\n         * @returns {String} Height\n         */\n        height: function (element) {\n          return element[0].getBoundingClientRect().height;\n        },\n\n        /**\n         * Get the width of an element.\n         *\n         * @param {Object} element Angular element.\n         * @returns {String} Width\n         */\n        width: function (element) {\n          return element[0].getBoundingClientRect().width;\n        },\n\n        /**\n         * Get the offset values of an element.\n         *\n         * @param {Object} element Angular element.\n         * @param {Object} [scrollableContainer] Scrollable container object for calculating relative top & left (optional, defaults to Document)\n         * @returns {Object} Object with properties width, height, top and left\n         */\n        offset: function (element, scrollableContainer) {\n          var boundingClientRect = element[0].getBoundingClientRect();\n          if (!scrollableContainer) {\n            scrollableContainer = $document[0].documentElement;\n          }\n\n          return {\n            width: boundingClientRect.width || element.prop('offsetWidth'),\n            height: boundingClientRect.height || element.prop('offsetHeight'),\n            top: boundingClientRect.top + ($window.pageYOffset || scrollableContainer.scrollTop - scrollableContainer.offsetTop),\n            left: boundingClientRect.left + ($window.pageXOffset || scrollableContainer.scrollLeft - scrollableContainer.offsetLeft)\n          };\n        },\n\n        /**\n         * get the event object for touch.\n         *\n         * @param  {Object} event the touch event\n         * @return {Object} the touch event object.\n         */\n        eventObj: function (event) {\n          var obj = event;\n          if (event.targetTouches !== undefined) {\n            obj = event.targetTouches.item(0);\n          } else if (event.originalEvent !== undefined && event.originalEvent.targetTouches !== undefined) {\n            obj = event.originalEvent.targetTouches.item(0);\n          }\n          return obj;\n        },\n\n        /**\n         * Checks whether the touch is valid and multiple.\n         *\n         * @param event the event object.\n         * @returns {boolean} true if touch is multiple.\n         */\n        isTouchInvalid: function (event) {\n\n          var touchInvalid = false;\n          if (event.touches !== undefined && event.touches.length > 1) {\n            touchInvalid = true;\n          } else if (event.originalEvent !== undefined &&\n              event.originalEvent.touches !== undefined && event.originalEvent.touches.length > 1) {\n            touchInvalid = true;\n          }\n          return touchInvalid;\n        },\n\n        /**\n         * Get the start position of the target element according to the provided event properties.\n         *\n         * @param {Object} event Event\n         * @param {Object} target Target element\n         * @param {Object} [scrollableContainer] (optional) Scrollable container object\n         * @returns {Object} Object with properties offsetX, offsetY.\n         */\n        positionStarted: function (event, target, scrollableContainer) {\n          var pos = {};\n          pos.offsetX = event.pageX - this.offset(target, scrollableContainer).left;\n          pos.offsetY = event.pageY - this.offset(target, scrollableContainer).top;\n          pos.startX = pos.lastX = event.pageX;\n          pos.startY = pos.lastY = event.pageY;\n          pos.nowX = pos.nowY = pos.distX = pos.distY = pos.dirAx = 0;\n          pos.dirX = pos.dirY = pos.lastDirX = pos.lastDirY = pos.distAxX = pos.distAxY = 0;\n          return pos;\n        },\n\n        /**\n         * Calculates the event position and sets the direction\n         * properties.\n         *\n         * @param pos the current position of the element.\n         * @param event the move event.\n         */\n        calculatePosition: function (pos, event) {\n          // mouse position last events\n          pos.lastX = pos.nowX;\n          pos.lastY = pos.nowY;\n\n          // mouse position this events\n          pos.nowX = event.pageX;\n          pos.nowY = event.pageY;\n\n          // distance mouse moved between events\n          pos.distX = pos.nowX - pos.lastX;\n          pos.distY = pos.nowY - pos.lastY;\n\n          // direction mouse was moving\n          pos.lastDirX = pos.dirX;\n          pos.lastDirY = pos.dirY;\n\n          // direction mouse is now moving (on both axis)\n          pos.dirX = pos.distX === 0 ? 0 : pos.distX > 0 ? 1 : -1;\n          pos.dirY = pos.distY === 0 ? 0 : pos.distY > 0 ? 1 : -1;\n\n          // axis mouse is now moving on\n          var newAx = Math.abs(pos.distX) > Math.abs(pos.distY) ? 1 : 0;\n\n          // calc distance moved on this axis (and direction)\n          if (pos.dirAx !== newAx) {\n            pos.distAxX = 0;\n            pos.distAxY = 0;\n          } else {\n            pos.distAxX += Math.abs(pos.distX);\n            if (pos.dirX !== 0 && pos.dirX !== pos.lastDirX) {\n              pos.distAxX = 0;\n            }\n\n            pos.distAxY += Math.abs(pos.distY);\n            if (pos.dirY !== 0 && pos.dirY !== pos.lastDirY) {\n              pos.distAxY = 0;\n            }\n          }\n          pos.dirAx = newAx;\n        },\n\n        /**\n         * Move the position by applying style.\n         *\n         * @param event the event object\n         * @param element - the dom element\n         * @param pos - current position\n         * @param container - the bounding container.\n         * @param containerPositioning - absolute or relative positioning.\n         * @param {Object} [scrollableContainer] (optional) Scrollable container object\n         */\n        movePosition: function (event, element, pos, container, containerPositioning, scrollableContainer) {\n          var bounds;\n          var useRelative = (containerPositioning === 'relative');\n\n          element.x = event.pageX - pos.offsetX;\n          element.y = event.pageY - pos.offsetY;\n\n          if (container) {\n            bounds = this.offset(container, scrollableContainer);\n\n            if (useRelative) {\n              // reduce positioning by bounds\n              element.x -= bounds.left;\n              element.y -= bounds.top;\n\n              // reset bounds\n              bounds.left = 0;\n              bounds.top = 0;\n            }\n\n            if (element.x < bounds.left) {\n              element.x = bounds.left;\n            } else if (element.x >= bounds.width + bounds.left - this.offset(element).width) {\n              element.x = bounds.width + bounds.left - this.offset(element).width;\n            }\n            if (element.y < bounds.top) {\n              element.y = bounds.top;\n            } else if (element.y >= bounds.height + bounds.top - this.offset(element).height) {\n              element.y = bounds.height + bounds.top - this.offset(element).height;\n            }\n          }\n\n          element.css({\n            'left': element.x + 'px',\n            'top': element.y + 'px'\n          });\n\n          this.calculatePosition(pos, event);\n        },\n\n        /**\n         * The drag item info and functions.\n         * retains the item info before and after move.\n         * holds source item and target scope.\n         *\n         * @param item - the drag item\n         * @returns {{index: *, parent: *, source: *,\n                 *          sourceInfo: {index: *, itemScope: (*|.dragItem.sourceInfo.itemScope|$scope.itemScope|itemScope), sortableScope: *},\n                 *         moveTo: moveTo, isSameParent: isSameParent, isOrderChanged: isOrderChanged, eventArgs: eventArgs, apply: apply}}\n         */\n        dragItem: function (item) {\n\n          return {\n            index: item.index(),\n            parent: item.sortableScope,\n            source: item,\n            sourceInfo: {\n              index: item.index(),\n              itemScope: item.itemScope,\n              sortableScope: item.sortableScope\n            },\n            moveTo: function (parent, index) { // Move the item to a new position\n              this.parent = parent;\n              //If source Item is in the same Parent.\n              if (this.isSameParent() && this.source.index() < index) { // and target after\n                index = index - 1;\n              }\n              this.index = index;\n            },\n            isSameParent: function () {\n              return this.parent.element === this.sourceInfo.sortableScope.element;\n            },\n            isOrderChanged: function () {\n              return this.index !== this.sourceInfo.index;\n            },\n            eventArgs: function () {\n              return {\n                source: this.sourceInfo,\n                dest: {\n                  index: this.index,\n                  sortableScope: this.parent\n                }\n              };\n            },\n            apply: function () {\n              this.sourceInfo.sortableScope.removeItem(this.sourceInfo.index); // Remove from source.\n              this.parent.insertItem(this.index, this.source.modelValue); // Insert in to destination.\n            }\n          };\n        },\n\n        /**\n         * Check the drag is not allowed for the element.\n         *\n         * @param element - the element to check\n         * @returns {boolean} - true if drag is not allowed.\n         */\n        noDrag: function (element) {\n          return element.attr('no-drag') !== undefined || element.attr('data-no-drag') !== undefined;\n        }\n      };\n    }\n  ]);\n\n}());\n/*jshint undef: false, unused: false, indent: 2*/\n/*global angular: false */\n\n(function () {\n\n  'use strict';\n  var mainModule = angular.module('as.sortable');\n\n  /**\n   * Controller for Sortable.\n   * @param $scope - the sortable scope.\n   */\n  mainModule.controller('as.sortable.sortableController', ['$scope', function ($scope) {\n\n    this.scope = $scope;\n\n    $scope.modelValue = null; // sortable list.\n    $scope.callbacks = null;\n    $scope.type = 'sortable';\n    $scope.options = {};\n    $scope.isDisabled = false;\n\n    /**\n     * Inserts the item in to the sortable list.\n     *\n     * @param index - the item index.\n     * @param itemData - the item model data.\n     */\n    $scope.insertItem = function (index, itemData) {\n      $scope.modelValue.splice(index, 0, itemData);\n    };\n\n    /**\n     * Removes the item from the sortable list.\n     *\n     * @param index - index to be removed.\n     * @returns {*} - removed item.\n     */\n    $scope.removeItem = function (index) {\n      var removedItem = null;\n      if (index > -1) {\n        removedItem = $scope.modelValue.splice(index, 1)[0];\n      }\n      return removedItem;\n    };\n\n    /**\n     * Checks whether the sortable list is empty.\n     *\n     * @returns {null|*|$scope.modelValue|boolean}\n     */\n    $scope.isEmpty = function () {\n      return ($scope.modelValue && $scope.modelValue.length === 0);\n    };\n\n    /**\n     * Wrapper for the accept callback delegates to callback.\n     *\n     * @param sourceItemHandleScope - drag item handle scope.\n     * @param destScope - sortable target scope.\n     * @param destItemScope - sortable destination item scope.\n     * @returns {*|boolean} - true if drop is allowed for the drag item in drop target.\n     */\n    $scope.accept = function (sourceItemHandleScope, destScope, destItemScope) {\n      return $scope.callbacks.accept(sourceItemHandleScope, destScope, destItemScope);\n    };\n\n  }]);\n\n  /**\n   * Sortable directive - defines callbacks.\n   * Parent directive for draggable and sortable items.\n   * Sets modelValue, callbacks, element in scope.\n   */\n  mainModule.directive('asSortable',\n      function () {\n        return {\n          require: 'ngModel', // get a hold of NgModelController\n          restrict: 'A',\n          scope: true,\n          controller: 'as.sortable.sortableController',\n          link: function (scope, element, attrs, ngModelController) {\n\n            var ngModel, callbacks;\n\n            ngModel = ngModelController;\n\n            if (!ngModel) {\n              return; // do nothing if no ng-model\n            }\n\n            // Set the model value in to scope.\n            ngModel.$render = function () {\n              scope.modelValue = ngModel.$modelValue;\n            };\n            //set the element in scope to be accessed by its sub scope.\n            scope.element = element;\n            element.data('_scope',scope); // #144, work with angular debugInfoEnabled(false)\n\n            callbacks = {accept: null, orderChanged: null, itemMoved: null, dragStart: null, dragMove:null, dragCancel: null, dragEnd: null};\n\n            /**\n             * Invoked to decide whether to allow drop.\n             *\n             * @param sourceItemHandleScope - the drag item handle scope.\n             * @param destSortableScope - the drop target sortable scope.\n             * @param destItemScope - the drop target item scope.\n             * @returns {boolean} - true if allowed for drop.\n             */\n            callbacks.accept = function (sourceItemHandleScope, destSortableScope, destItemScope) {\n              return true;\n            };\n\n            /**\n             * Invoked when order of a drag item is changed.\n             *\n             * @param event - the event object.\n             */\n            callbacks.orderChanged = function (event) {\n            };\n\n            /**\n             * Invoked when the item is moved to other sortable.\n             *\n             * @param event - the event object.\n             */\n            callbacks.itemMoved = function (event) {\n            };\n\n            /**\n             * Invoked when the drag started successfully.\n             *\n             * @param event - the event object.\n             */\n            callbacks.dragStart = function (event) {\n            };\n\n            /**\n             * Invoked when the drag started successfully.\n             *\n             * @param event - the event object.\n             */\n            callbacks.dragMove = angular.noop;\n\n            /**\n             * Invoked when the drag cancelled.\n             *\n             * @param event - the event object.\n             */\n            callbacks.dragCancel = function (event) {\n            };\n\n            /**\n             * Invoked when the drag stopped.\n             *\n             * @param event - the event object.\n             */\n            callbacks.dragEnd = function (event) {\n            };\n\n            //Set the sortOptions callbacks else set it to default.\n            scope.$watch(attrs.asSortable, function (newVal, oldVal) {\n              angular.forEach(newVal, function (value, key) {\n                if (callbacks[key]) {\n                  if (typeof value === 'function') {\n                    callbacks[key] = value;\n                  }\n                } else {\n                  scope.options[key] = value;\n                }\n              });\n              scope.callbacks = callbacks;\n            }, true);\n\n            // Set isDisabled if attr is set, if undefined isDisabled = false\n            if (angular.isDefined(attrs.isDisabled)) {\n              scope.$watch(attrs.isDisabled, function (newVal, oldVal) {\n                if (!angular.isUndefined(newVal)) {\n                  scope.isDisabled = newVal;\n                }\n              }, true);\n            }\n          }\n        };\n      });\n\n}());\n\n/*jshint indent: 2 */\n/*global angular: false */\n\n(function () {\n\n  'use strict';\n  var mainModule = angular.module('as.sortable');\n\n  /**\n   * Controller for sortableItemHandle\n   *\n   * @param $scope - item handle scope.\n   */\n  mainModule.controller('as.sortable.sortableItemHandleController', ['$scope', function ($scope) {\n\n    this.scope = $scope;\n\n    $scope.itemScope = null;\n    $scope.type = 'handle';\n  }]);\n\n  /**\n   * Directive for sortable item handle.\n   */\n  mainModule.directive('asSortableItemHandle', ['sortableConfig', '$helper', '$window', '$document',\n    function (sortableConfig, $helper, $window, $document) {\n      return {\n        require: '^asSortableItem',\n        scope: true,\n        restrict: 'A',\n        controller: 'as.sortable.sortableItemHandleController',\n        link: function (scope, element, attrs, itemController) {\n\n          var dragElement, //drag item element.\n              placeHolder, //place holder class element.\n              placeElement,//hidden place element.\n              itemPosition, //drag item element position.\n              dragItemInfo, //drag item data.\n              containment,//the drag container.\n              containerPositioning, // absolute or relative positioning.\n              dragListen,// drag listen event.\n              scrollableContainer, //the scrollable container\n              dragStart,// drag start event.\n              dragMove,//drag move event.\n              dragEnd,//drag end event.\n              dragCancel,//drag cancel event.\n              isDraggable,//is element draggable.\n              placeHolderIndex,//placeholder index in items elements.\n              bindDrag,//bind drag events.\n              unbindDrag,//unbind drag events.\n              bindEvents,//bind the drag events.\n              unBindEvents,//unbind the drag events.\n              hasTouch,// has touch support.\n              dragHandled, //drag handled.\n              createPlaceholder,//create place holder.\n              isPlaceHolderPresent,//is placeholder present.\n              isDisabled = false; // drag enabled\n\n          hasTouch = $window.hasOwnProperty('ontouchstart');\n\n          if (sortableConfig.handleClass) {\n            element.addClass(sortableConfig.handleClass);\n          }\n\n          scope.itemScope = itemController.scope;\n          element.data('_scope', scope); // #144, work with angular debugInfoEnabled(false)\n\n          scope.$watch('sortableScope.isDisabled', function (newVal) {\n            if (isDisabled !== newVal) {\n              isDisabled = newVal;\n              if (isDisabled) {\n                unbindDrag();\n              } else {\n                bindDrag();\n              }\n            }\n          });\n\n          createPlaceholder = function (itemScope) {\n            if (typeof scope.sortableScope.options.placeholder === 'function') {\n              return angular.element(scope.sortableScope.options.placeholder(itemScope));\n            } else if (typeof scope.sortableScope.options.placeholder === 'string') {\n              return angular.element(scope.sortableScope.options.placeholder);\n            } else {\n              return angular.element($document[0].createElement(itemScope.element.prop('tagName')));\n            }\n          };\n\n          /**\n           * Listens for a 10px movement before\n           * dragStart is called to allow for\n           * a click event on the element.\n           *\n           * @param event - the event object.\n           */\n          dragListen = function (event) {\n\n            var unbindMoveListen = function () {\n              angular.element($document).unbind('mousemove', moveListen);\n              angular.element($document).unbind('touchmove', moveListen);\n              element.unbind('mouseup', unbindMoveListen);\n              element.unbind('touchend', unbindMoveListen);\n              element.unbind('touchcancel', unbindMoveListen);\n            };\n\n            var startPosition;\n            var moveListen = function (e) {\n              e.preventDefault();\n              var eventObj = $helper.eventObj(e);\n              if (!startPosition) {\n                startPosition = { clientX: eventObj.clientX, clientY: eventObj.clientY };\n              }\n              if (Math.abs(eventObj.clientX - startPosition.clientX) + Math.abs(eventObj.clientY - startPosition.clientY) > 10) {\n                unbindMoveListen();\n                dragStart(event);\n              }\n            };\n\n            angular.element($document).bind('mousemove', moveListen);\n            angular.element($document).bind('touchmove', moveListen);\n            element.bind('mouseup', unbindMoveListen);\n            element.bind('touchend', unbindMoveListen);\n            element.bind('touchcancel', unbindMoveListen);\n          };\n\n          /**\n           * Triggered when drag event starts.\n           *\n           * @param event the event object.\n           */\n          dragStart = function (event) {\n\n            var eventObj, tagName;\n\n            if (!hasTouch && (event.button === 2 || event.which === 3)) {\n              // disable right click\n              return;\n            }\n            if (hasTouch && $helper.isTouchInvalid(event)) {\n              return;\n            }\n            if (dragHandled || !isDraggable(event)) {\n              // event has already fired in other scope.\n              return;\n            }\n            // Set the flag to prevent other items from inheriting the drag event\n            dragHandled = true;\n            event.preventDefault();\n            eventObj = $helper.eventObj(event);\n\n            // (optional) Scrollable container as reference for top & left offset calculations, defaults to Document\n            scrollableContainer = angular.element($document[0].querySelector(scope.sortableScope.options.scrollableContainer)).length > 0 ?\n                $document[0].querySelector(scope.sortableScope.options.scrollableContainer) : $document[0].documentElement;\n\n            containment = angular.element($document[0].querySelector(scope.sortableScope.options.containment)).length > 0 ?\n                angular.element($document[0].querySelector(scope.sortableScope.options.containment)) : angular.element($document[0].body);\n            //capture mouse move on containment.\n            containment.css('cursor', 'move');\n            containment.addClass('as-sortable-un-selectable');\n\n            // container positioning\n            containerPositioning = scope.sortableScope.options.containerPositioning || 'absolute';\n\n            dragItemInfo = $helper.dragItem(scope);\n            tagName = scope.itemScope.element.prop('tagName');\n\n            dragElement = angular.element($document[0].createElement(scope.sortableScope.element.prop('tagName')))\n                .addClass(scope.sortableScope.element.attr('class')).addClass(sortableConfig.dragClass);\n            dragElement.css('width', $helper.width(scope.itemScope.element) + 'px');\n            dragElement.css('height', $helper.height(scope.itemScope.element) + 'px');\n\n            placeHolder = createPlaceholder(scope.itemScope)\n                .addClass(sortableConfig.placeHolderClass).addClass(scope.sortableScope.options.additionalPlaceholderClass);\n            placeHolder.css('width', $helper.width(scope.itemScope.element) + 'px');\n            placeHolder.css('height', $helper.height(scope.itemScope.element) + 'px');\n\n            placeElement = angular.element($document[0].createElement(tagName));\n            if (sortableConfig.hiddenClass) {\n              placeElement.addClass(sortableConfig.hiddenClass);\n            }\n\n            itemPosition = $helper.positionStarted(eventObj, scope.itemScope.element, scrollableContainer);\n            //fill the immediate vacuum.\n            scope.itemScope.element.after(placeHolder);\n            //hidden place element in original position.\n            scope.itemScope.element.after(placeElement);\n            dragElement.append(scope.itemScope.element);\n\n            containment.append(dragElement);\n            $helper.movePosition(eventObj, dragElement, itemPosition, containment, containerPositioning, scrollableContainer);\n\n            scope.sortableScope.$apply(function () {\n              scope.callbacks.dragStart(dragItemInfo.eventArgs());\n            });\n            bindEvents();\n          };\n\n          /**\n           * Allow Drag if it is a proper item-handle element.\n           *\n           * @param event - the event object.\n           * @return boolean - true if element is draggable.\n           */\n          isDraggable = function (event) {\n\n            var elementClicked, sourceScope, isDraggable;\n\n            elementClicked = angular.element(event.target);\n\n            // look for the handle on the current scope or parent scopes\n            sourceScope = fetchScope(elementClicked);\n\n            isDraggable = (sourceScope && sourceScope.type === 'handle');\n\n            //If a 'no-drag' element inside item-handle if any.\n            while (isDraggable && elementClicked[0] !== element[0]) {\n              if ($helper.noDrag(elementClicked)) {\n                isDraggable = false;\n              }\n              elementClicked = elementClicked.parent();\n            }\n            return isDraggable;\n          };\n\n          /**\n           * Inserts the placeHolder in to the targetScope.\n           *\n           * @param targetElement the target element\n           * @param targetScope the target scope\n           */\n          function insertBefore(targetElement, targetScope) {\n            targetElement[0].parentNode.insertBefore(placeHolder[0], targetElement[0]);\n            dragItemInfo.moveTo(targetScope.sortableScope, targetScope.index());\n          }\n\n          /**\n           * Inserts the placeHolder next to the targetScope.\n           *\n           * @param targetElement the target element\n           * @param targetScope the target scope\n           */\n          function insertAfter(targetElement, targetScope) {\n            targetElement.after(placeHolder);\n            dragItemInfo.moveTo(targetScope.sortableScope, targetScope.index() + 1);\n          }\n\n          /**\n           * Triggered when drag is moving.\n           *\n           * @param event - the event object.\n           */\n          dragMove = function (event) {\n\n            var eventObj, targetX, targetY, targetScope, targetElement;\n\n            if (hasTouch && $helper.isTouchInvalid(event)) {\n              return;\n            }\n            // Ignore event if not handled\n            if (!dragHandled) {\n              return;\n            }\n            if (dragElement) {\n\n              event.preventDefault();\n\n              eventObj = $helper.eventObj(event);\n\n              // checking if dragMove callback exists, to prevent application\n              // rerenderings on each mouse move event\n              if (scope.callbacks.dragMove !== angular.noop) {\n                scope.sortableScope.$apply(function () {\n                  scope.callbacks.dragMove(itemPosition, containment, eventObj);\n                });\n              }\n\n              $helper.movePosition(eventObj, dragElement, itemPosition, containment, containerPositioning, scrollableContainer);\n\n              targetX = eventObj.pageX - $document[0].documentElement.scrollLeft;\n              targetY = eventObj.pageY - ($window.pageYOffset || $document[0].documentElement.scrollTop);\n\n              //IE fixes: hide show element, call element from point twice to return pick correct element.\n              dragElement.addClass(sortableConfig.hiddenClass);\n              $document[0].elementFromPoint(targetX, targetY);\n              targetElement = angular.element($document[0].elementFromPoint(targetX, targetY));\n              dragElement.removeClass(sortableConfig.hiddenClass);\n\n              //Set Class as dragging starts\n              dragElement.addClass(sortableConfig.dragging);\n\n              targetScope = fetchScope(targetElement);\n\n              if (!targetScope || !targetScope.type) {\n                return;\n              }\n              if (targetScope.type === 'handle') {\n                targetScope = targetScope.itemScope;\n              }\n              if (targetScope.type !== 'item' && targetScope.type !== 'sortable') {\n                return;\n              }\n\n              if (targetScope.type === 'item' && targetScope.accept(scope, targetScope.sortableScope, targetScope)) {\n                // decide where to insert placeholder based on target element and current placeholder if is present\n                targetElement = targetScope.element;\n\n                var placeholderIndex = placeHolderIndex(targetScope.sortableScope.element);\n                if (placeholderIndex < 0) {\n                  insertBefore(targetElement, targetScope);\n                } else {\n                  if (placeholderIndex <= targetScope.index()) {\n                    insertAfter(targetElement, targetScope);\n                  } else {\n                    insertBefore(targetElement, targetScope);\n                  }\n                }\n              }\n\n              if (targetScope.type === 'sortable') {//sortable scope.\n                if (targetScope.accept(scope, targetScope) &&\n                    targetElement[0].parentNode !== targetScope.element[0]) {\n                  //moving over sortable bucket. not over item.\n                  if (!isPlaceHolderPresent(targetElement)) {\n                    targetElement[0].appendChild(placeHolder[0]);\n                    dragItemInfo.moveTo(targetScope, targetScope.modelValue.length);\n                  }\n                }\n              }\n            }\n          };\n\n\n          /**\n           * Fetch scope from element or parents\n           * @param  {object} element Source element\n           * @return {object}         Scope, or null if not found\n           */\n          function fetchScope(element) {\n            var scope;\n            while (!scope && element.length) {\n              scope = element.data('_scope');\n              if (!scope) {\n                element = element.parent();\n              }\n            }\n            return scope;\n          }\n\n\n          /**\n           * Get position of place holder among item elements in itemScope.\n           * @param targetElement the target element to check with.\n           * @returns {*} -1 if placeholder is not present, index if yes.\n           */\n          placeHolderIndex = function (targetElement) {\n            var itemElements, i;\n\n            itemElements = targetElement.children();\n            for (i = 0; i < itemElements.length; i += 1) {\n              //TODO may not be accurate when elements contain other siblings than item elements\n              //solve by adding 1 to model index of previous item element\n              if (angular.element(itemElements[i]).hasClass(sortableConfig.placeHolderClass)) {\n                return i;\n              }\n            }\n            return -1;\n          };\n\n\n          /**\n           * Check there is no place holder placed by itemScope.\n           * @param targetElement the target element to check with.\n           * @returns {*} true if place holder present.\n           */\n          isPlaceHolderPresent = function (targetElement) {\n            return placeHolderIndex(targetElement) >= 0;\n          };\n\n          /**\n           * Rollback the drag data changes.\n           */\n\n          function rollbackDragChanges() {\n            placeElement.replaceWith(scope.itemScope.element);\n            placeHolder.remove();\n            dragElement.remove();\n            dragElement = null;\n            dragHandled = false;\n            containment.css('cursor', '');\n            containment.removeClass('as-sortable-un-selectable');\n          }\n\n          /**\n           * triggered while drag ends.\n           *\n           * @param event - the event object.\n           */\n          dragEnd = function (event) {\n            // Ignore event if not handled\n            if (!dragHandled) {\n              return;\n            }\n            event.preventDefault();\n            if (dragElement) {\n              //rollback all the changes.\n              rollbackDragChanges();\n              // update model data\n              dragItemInfo.apply();\n              scope.sortableScope.$apply(function () {\n                if (dragItemInfo.isSameParent()) {\n                  if (dragItemInfo.isOrderChanged()) {\n                    scope.callbacks.orderChanged(dragItemInfo.eventArgs());\n                  }\n                } else {\n                  scope.callbacks.itemMoved(dragItemInfo.eventArgs());\n                }\n              });\n              scope.sortableScope.$apply(function () {\n                scope.callbacks.dragEnd(dragItemInfo.eventArgs());\n              });\n              dragItemInfo = null;\n            }\n            unBindEvents();\n          };\n\n          /**\n           * triggered while drag is cancelled.\n           *\n           * @param event - the event object.\n           */\n          dragCancel = function (event) {\n            // Ignore event if not handled\n            if (!dragHandled) {\n              return;\n            }\n            event.preventDefault();\n\n            if (dragElement) {\n              //rollback all the changes.\n              rollbackDragChanges();\n              scope.sortableScope.$apply(function () {\n                scope.callbacks.dragCancel(dragItemInfo.eventArgs());\n              });\n              dragItemInfo = null;\n            }\n            unBindEvents();\n          };\n\n          /**\n           * Binds the drag start events.\n           */\n          bindDrag = function () {\n            element.bind('touchstart', dragListen);\n            element.bind('mousedown', dragListen);\n          };\n\n          /**\n           * Unbinds the drag start events.\n           */\n          unbindDrag = function () {\n            element.unbind('touchstart', dragListen);\n            element.unbind('mousedown', dragListen);\n          };\n\n          //bind drag start events.\n          bindDrag();\n\n          //Cancel drag on escape press.\n          angular.element($document[0].body).bind('keydown', function (event) {\n            if (event.keyCode === 27) {\n              dragCancel(event);\n            }\n          });\n\n          /**\n           * Binds the events based on the actions.\n           */\n          bindEvents = function () {\n            angular.element($document).bind('touchmove', dragMove);\n            angular.element($document).bind('touchend', dragEnd);\n            angular.element($document).bind('touchcancel', dragCancel);\n            angular.element($document).bind('mousemove', dragMove);\n            angular.element($document).bind('mouseup', dragEnd);\n          };\n\n          /**\n           * Un binds the events for drag support.\n           */\n          unBindEvents = function () {\n            angular.element($document).unbind('touchend', dragEnd);\n            angular.element($document).unbind('touchcancel', dragCancel);\n            angular.element($document).unbind('touchmove', dragMove);\n            angular.element($document).unbind('mouseup', dragEnd);\n            angular.element($document).unbind('mousemove', dragMove);\n          };\n        }\n      };\n    }]);\n}());\n\n/*jshint indent: 2 */\n/*global angular: false */\n\n(function () {\n\n  'use strict';\n  var mainModule = angular.module('as.sortable');\n\n  /**\n   * Controller for sortable item.\n   *\n   * @param $scope - drag item scope\n   */\n  mainModule.controller('as.sortable.sortableItemController', ['$scope', function ($scope) {\n\n    this.scope = $scope;\n\n    $scope.sortableScope = null;\n    $scope.modelValue = null; // sortable item.\n    $scope.type = 'item';\n\n    /**\n     * returns the index of the drag item from the sortable list.\n     *\n     * @returns {*} - index value.\n     */\n    $scope.index = function () {\n      return $scope.$index;\n    };\n\n    /**\n     * Returns the item model data.\n     *\n     * @returns {*} - item model value.\n     */\n    $scope.itemData = function () {\n      return $scope.sortableScope.modelValue[$scope.$index];\n    };\n\n  }]);\n\n  /**\n   * sortableItem directive.\n   */\n  mainModule.directive('asSortableItem', ['sortableConfig',\n    function (sortableConfig) {\n      return {\n        require: ['^asSortable', '?ngModel'],\n        restrict: 'A',\n        controller: 'as.sortable.sortableItemController',\n        link: function (scope, element, attrs, ctrl) {\n          var sortableController = ctrl[0];\n          var ngModelController = ctrl[1];\n          if (sortableConfig.itemClass) {\n            element.addClass(sortableConfig.itemClass);\n          }\n          scope.sortableScope = sortableController.scope;\n          if (ngModelController) {\n            ngModelController.$render = function () {\n              scope.modelValue = ngModelController.$modelValue;\n            };\n          } else {\n            scope.modelValue = sortableController.scope.modelValue[scope.$index];\n          }\n          scope.element = element;\n          element.data('_scope',scope); // #144, work with angular debugInfoEnabled(false)\n        }\n      };\n    }]);\n\n}());\n(function () {\n    'use strict';\n\n    angular.module('rl-instrumentation', ['ngResource']);\n\n})();\n\n(function () {\n    'use strict';\n\n    angular\n        .module('rl-instrumentation')\n\t\t.factory('rlInstrumentationService', instrumentationService);\n\n    instrumentationService.$inject = ['$resource', 'emsUrl', 'userContext'];\n\n    function instrumentationService($resource, emsUrl, userContext) {\n        var instrumentationResource = $resource(emsUrl);\n        var service = {\n            constructAndSendMessage: constructAndSendMessage,\n            generateId: generateId\n        };\n        return service;\n\n        function constructAndSendMessage(data, type, source) {\n            if (!type) throw new Error(\"type required send instrumentation\");\n            if (!source) throw new Error(\"source required send instrumentation\");\n\n            var msg = {\n                Id: generateId(),\n                Source: source,\n                Type: type,\n                ClientId: userContext.clientId,\n                SchoolId: userContext.schoolId,\n                SessionId: userContext.sessionGuid,\n                UserId: userContext.userId,\n                ClassId: userContext.classId,\n                Timestamp: (new Date()).toISOString(),\n                Data: data\n            };\n\n            instrumentationResource.save(msg);\n        }\n\n        function generateId() {\n\n            var time = new Date().getTime(), sixteen = 16;\n\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (match) {\n                var remainder = (time + sixteen * Math.random()) % sixteen | 0;\n                time = Math.floor(time / sixteen);\n                return (match == \"x\" ? remainder : remainder & 7 | 8).toString(sixteen);\n            });\n        }\n\n    }\n\n})();\n\n\n"],"sourceRoot":"/source/"}